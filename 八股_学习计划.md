# 八股文学习计划

## Day1 - OSI 模型和 TCP/IP 模型

### OSI 模型

**掌握程度：**
- 理解 OSI 模型共有 7 层，能够说明是哪 7 层
- 能够粗浅描述每一层的基本功能和职责
- 对于某些层，熟悉一些常见的协议，比如网络层的 IP，传输层的 TCP 和 UDP

### TCP/IP 模型

**掌握程度：**
- 理解 TCP/IP 模型通常被描述为 4 层，能够清晰地描述网络模型的层次结构
- 能够解释每一层的作用，知道 TCP/IP 模型的层次是如何与 OSI 模型相对应的
- 能够举例说明每层使用的协议，对某些层次的深入理解，比如 TCP 的三次握手、四次挥手，IP 数据报的路由选择
- 理解不同层次间的交互：了解数据是如何在这些层次之间流动的，以及每一层如何为数据的传输添加或移除其所需的头部信息

**参考学习资料：**
- 小林coding: TCP/IP 网络模型有哪几层？

---

## Day1 - 从输入URL到页面展示发生了什么

本道题目是一个综合题目，需要对 HTTP、DNS 查询、TCP 三次握手四次挥手、浏览器渲染等概念有更深入的认识之后才能回答得更加完善深入。

**掌握程度：**
- **基本要求：** 理解浏览器和服务器之间的交互过程，能够清晰地描述从输入URL到页面显示的整个流程
  - DNS解析: 描述如何将域名转换为IP地址
  - TCP连接建立: 解释TCP三次握手的过程
  - HTTP请求: 说明浏览器如何构建HTTP请求，并发送到服务器
  - 服务器处理请求: 描述服务器接收请求、处理请求并生成响应的过程
  - HTTP响应: 说明服务器如何将响应发送回浏览器
  - TCP连接关闭: 描述TCP四次挥手的过程
  - 浏览器渲染页面: 描述浏览器如何解析HTML、CSS和JavaScript，以及构建DOM树和渲染树
  - 页面显示: 解释浏览器如何将渲染树绘制到屏幕上

- **进阶要求：** 对每个步骤的关键点有所了解，如DNS解析、TCP/IP连接、HTTP请求和响应、浏览器渲染等，引导面试官向具体的问题深入
- **进阶要求：** 对页面加载性能优化有所了解，如减少DNS查询时间、使用CDN、压缩资源、利用缓存等

**参考学习资料：**
- 技术蛋老师：【在浏览器输入URL回车之后发生了什么？】
- 小林coding: 从输入URL到页面渲染发生了什么
- 面试示范：【面试官：请说一下浏览器从输入URL 到页面展示这个过程中都经历了什么？你能答出来吗？】
- 视频：【2分钟了解输入URL到页面呈现发生了什么？构建前端知识体系】

---

## Day2 - HTTP请求报文和响应报文是怎样的

**掌握程度：**
- **基本结构:** 能够描述HTTP请求报文和响应报文的基本结构和各部分的作用
- **关键字段:** 对请求行、状态行、请求头和响应头中的常见字段有所了解
- **后续延伸知识点：**
  - HTTP方法: 能够区分并解释不同的HTTP方法及其用途
  - HTTP版本：熟悉 HTTP 不同版本的特性和之间的区别
  - 状态码: 熟悉常见的HTTP状态码及其含义，特别是2xx、3xx、4xx和5xx系列
  - 安全：了解HTTPS、SSL/TLS等安全协议及其在HTTP中的应用
  - 优化：知道如何通过请求头和响应头进行性能优化，比如使用ETag、Last-Modified等字段进行 HTTP 缓存控制

**参考学习资料：**
- 建议阅读：MDN文档：HTTP
- 技术蛋老师：【HTTP是什么？】
- 小林coding: HTTP面试题
- 基本概念不了解的可以看【HTTP_1.1请求报文格式】
- 基本概念不了解的可以看【HTTP_1.1响应报文格式】

---

## Day2 - HTTP请求方式有哪些

**掌握程度：**
- **方法定义:** 能够清晰地定义每个请求方法的基本用途，知道哪些方法可能会改变服务器状态，哪些不会，并能够根据场景选择合适的HTTP方法
- **安全性:** 了解每种方法在安全性方面的考虑，特别是GET和POST方法的区别
- **幂等性:** 理解幂等性的概念，并能识别哪些HTTP方法是幂等的（如GET、PUT、DELETE）

**参考资料：**
- MDN文档：HTTP请求方法
- 菜鸟教程：HTTP请求方法

---

## Day2 - GET请求和POST请求的区别

**掌握程度：**
- 能够清晰地描述GET和POST请求的基本区别和各自的用途，能够根据场景选择合适的请求方法
- 知道GET请求数据附加在URL中，POST请求数据在请求体中
- 理解GET和POST请求在安全性和幂等性方面的差异

**参考资料：**
- 小林coding: GET请求和POST请求的区别
- MDN文档：POST方法
- MDN文档：GET方法

---

## Day3 - HTTP请求中常见的状态码

**掌握程度：**
- **状态码：** 能够根据1xx、2xx、3xx、4xx、5xx分类描述状态码，并对每个类别中的常见状态码能够解释其含义和使用场景
- **缓存：** 知道3xx状态码中的重定向是如何工作的
- **进阶：** 能够结合实际案例来讨论状态码的使用

**参考资料：**
- 【学习新姿势】用说唱RAP学会常用HTTP状态码
- MDN: HTTP响应状态码
- 小林coding: HTTP请求中常见的状态码有哪些

---

## Day3 - 什么是强缓存和协商缓存

**掌握程度：**
- **基本概念：** 区分强缓存和协商缓存的概念，并解释它们的不同用途
- **工作流程:** 能够描述浏览器和服务器在强缓存和协商缓存中如何交互
- **HTTP头部字段:** 知道实现强缓存和协商缓存的HTTP头部字段，如 Cache-Control, Last-Modified, ETag, If-Modified-Since, If-None-Match
- **性能优化:** 理解缓存机制如何提高Web应用的性能和用户体验

**参考资料：**
- 小林coding: HTTP缓存
- 视频解析：【HTTP缓存过程】
- MDN文档

---

## Day4 - HTTP1.0和HTTP1.1的区别

**掌握程度：**
- **特性：** 掌握 HTTP1.1 的特性，能够描述其优缺点
- **主要区别:** 能够清晰地描述HTTP/1.0和HTTP/1.1的主要区别（持久连接和管道）
- **持久连接:** 知道HTTP/1.1支持持久连接
- **管道化:** 理解HTTP/1.1的管道化技术

**参考资料：**
- 技术蛋老师：【HTTP/1.1，HTTP/2和HTTP/3的区别】
- 小林coding: HTTP1.1特性

---

## Day4 - HTTP2.0与HTTP1.1的区别？

**掌握程度**
- **改进之处：** 了解 HTTP/1.1 协议存在的性能问题
- **头部压缩:** 了解 HTTP/2 的头部压缩机制，以及它如何减少数据传输量
- **二进制协议:** 理解 HTTP/2 使用二进制协议对性能的改进
- **多路复用:** 知道 HTTP/2 支持在单个连接上并行发送多个请求和响应，以及它如何减少连接开销
- **服务器推送:** 知道服务器推送的概念，以及它如何帮助优化页面加载时间
- **协议细节:** 对 HTTP/2 的协议细节有深入了解，如帧的类型和用途、流的状态管理等
- **理解 HTTP/2 队头阻塞问题的原因**

**参考资料：**
- 小林coding: HTTP/2做了什么优化
- 小林coding: HTTP/2 牛逼在哪？

---

## Day4 - HTTP3.0有了解过吗？

**掌握程度**
- **QUIC 协议:** 理解 HTTP/3 是基于 UDP 的 QUIC 协议 而不是 TCP
- **性能提升:** 知道 HTTP/3 相对于 HTTP/2 在性能上的提升，特别是在连接建立和 队头阻塞 方面

**加分项：**
- **技术细节:** 对 QUIC 协议的技术细节有深入了解，如它的数据包结构、传输机制等
- **性能对比:** 能够对比 HTTP/2 和 HTTP/3 在性能和使用场景上的差异

**参考资料：**
- 小林coding: HTTP/3 做了哪些优化？
- 小林coding: HTTP/3 强势来袭
- 极客时间：HTTP专栏

---

## Day5 - HTTPS和HTTP有哪些区别

**掌握程度：**
- **基本概念：** 理解 HTTP 和 HTTPS 的基本概念
- **主要区别：** 能够清晰地区分 HTTP 和 HTTPS 的主要特点和用途，以及在安全性、加密、端口号、证书等方面的区别
- **安全性：** 理解 HTTPS 如何通过加密技术提高数据传输的安全性

**参考资料：**
- 小林coding: HTTPS和HTTP有哪些区别
- 【HTTPS是什么？加密原理和证书。SSL/TLS握手过程】

---

## Day5 - HTTPS工作原理

**掌握程度：**
- 理解HTTPS通过SSL/TLS 协议来提供安全性
- 理解SSL/TLS握手过程的各个步骤，包括证书的验证和密钥交换
- 知道非对称加密和对称加密在HTTPS中的作用和区别
- 了解数据完整性和身份验证的重要性。知道HTTPS使用数字证书来验证服务器的身份，这些证书通常由受信任的证书颁发机构(CA)签发。理解如何使用消息认证码(MAC)或数字签名来确保数据在传输过程中的完整性

**加分项：**
- 能够讨论HTTPS对性能的影响以及如何优化

**参考资料：**
- 【HTTPS是什么？加密原理和证书。SSL/TLS握手过程】
- 小林coding: HTTPS连接过程
- 小林coding: HTTPS如何优化

---

## Day5 - TCP和UDP的区别

**掌握程度：**
- **可以仅做了解：** 了解TCP和UDP的报文结构和传输方式
- 能够清晰地描述TCP和UDP的基本特性和区别，理解TCP的可靠性和UDP的效率
- 知道TCP和UDP在不同应用场景下的适用性
- **协议细节：** 对TCP和UDP的协议细节有深入了解，如TCP的三次握手、UDP的校验和计算等
- **延伸项（需要掌握）：** 能够讨论TCP的流量控制和拥塞控制机制
- **加分项：** 了解如何在实际应用中根据需求选择和优化TCP或UDP的使用

**参考资料：**
- 【计算机网络微课堂第067讲 UDP和TCP的对比】

---

## Day6 - TCP连接如何确保可靠性

**掌握程度：**
- 能够清晰地描述TCP协议的工作原理和关键特性
- 理解TCP如何通过各种机制确保数据传输的可靠性
  - 连接管理：三次握手，四次挥手
  - 差错控制：序列号和确认应答机制
  - 超时重传机制
  - 流量控制
  - 拥塞控制
- 知道TCP的流量控制和拥塞控制对于网络性能的影响

**参考资料：**
- 小林coding: TCP如何确保可靠性
- 『深入 TCP/IP 系列』一文搞懂 TCP 的可靠性

---

## Day6 - TCP 拥塞控制机制

**掌握程度：**
- 能够解释为什么需要拥塞控制，即动态调整数据的发送速率，防止网络过载，保证网络的稳定和高效
- 掌握拥塞控制的主要算法
  - 慢启动：开始时，发送窗口大小逐渐增加，直到达到一个阈值
  - 拥塞避免：超过阈值后，窗口大小增长速度减慢，采用线性增长
  - 快重传：当接收方检测到失序的包时，立即发送重复确认，触发发送方进行重传
  - 快恢复：在快重传后，不立即回到慢启动状态，而是尝试继续以当前窗口大小发送

**参考资料：**
- 【计算机网络微课堂第069讲 TCP的拥塞控制】

---

## Day6 - TCP 流量控制机制

**掌握程度**
- 能够解释流量控制的目的。能够清晰地描述TCP流量控制的基本工作原理和关键组件
- 知道 TCP 是使用滑动窗口机制来实现流量控制，理解TCP滑动窗口协议的工作原理，包括窗口大小的通告和更新
- 知道流量控制与拥塞控制的区别和它们在TCP中的作用
- 了解TCP报文结构，特别是与流量控制相关的字段

**参考资料：**
- 【计算机网络微课堂第068讲 TCP的流量控制】

---

## Day6 - UDP怎么实现可靠传输

**参考资料：**
- 小林coding: 如何基于 UDP 协议实现可靠传输？

---

## Day8 - 三次握手

**掌握程度：**
- 能够清晰地描述TCP三次握手的每个步骤和目的
- 理解序列号和确认号的重要性，以及它们在建立连接中的作用
- **扩展：** 知道三次握手过程中可能存在的安全问题，如SYN洪泛攻击，以及如何防范

**参考资料：**
- 动画解析：【一条视频讲清楚TCP协议与UDP协议-什么是三次握手与四次挥手】
- 模拟回答：【面试官居然把TCP三次握手问得这么详细】

---

## Day8 - 四次挥手的过程

**掌握程度：**
- 能够清晰地描述TCP四次挥手的每个步骤和原因
- 知道TIME-WAIT状态的重要性和2MSL等待期的作用

**参考资料：**
- 动画解析：【一条视频讲清楚TCP协议与UDP协议-什么是三次握手与四次挥手】

---

## Day8 - HTTP的Keep-Alive是什么？TCP 的 Keepalive 和 HTTP 的 Keep-Alive 是一个东西吗？

**掌握程度：**
- 能够清晰地解释HTTP的Keep-Alive和TCP的Keepalive的概念及其目的。知道HTTP的Keep-Alive如何通过HTTP头启用，以及TCP的Keepalive如何通过系统设置或编程接口配置
- 理解两者在网络通信中的作用和区别
  - HTTP的Keep-Alive是一种机制，允许客户端和服务器在单个TCP连接上发送多个HTTP请求和响应，而不是每个请求/响应后都关闭连接
  - TCP的Keepalive用于检测和清除死TCP连接

**参考资料：**
- 小林coding: TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？
- 视频解析（过长）：HTTP长连接和短连接？(http keep_alive tcp keep_alive 心跳检测机制】

---

## Day9 - DNS 查询过程

**掌握程度：**
- 了解 DNS 概念及其作用
- 能够清晰地描述DNS查询的基本过程，包括递归查询和迭代查询
- 知道DNS查询可能涉及的不同层级的DNS服务器

**参考资料：**
- 技术蛋老师：【DNS域名解析过程】
- 小林coding: DNS域名解析过程

---

## Day9 - CDN 是什么

**掌握程度：**
- 能够清晰地描述CDN的概念、工作原理和主要优势
- 理解CDN的关键组件和缓存策略
- 知道CDN在提高网站性能和用户体验方面的作用

**参考资料：**
- 【什么是CDN？CDN能为我们做什么？我们为什么要了解他？】

---

## Day9 - Cookie和Session是什么？有什么区别？

**掌握程度：**
- 能够清晰地描述Cookie和Session的定义、存储位置、生命周期、大小限制和安全性
- 理解Cookie和Session的使用场景和它们在Web应用中的不同作用
- 能够讨论Cookie和Session的安全性问题以及如何提高它们的安全性

**扩展：**
- 结合案例讨论Cookie和Session的使用
- 了解如何通过设置HttpOnly、Secure标志，以及使用SameSite属性来提高Cookie的安全性

**参考资料：**
- 【Cookie、Session、Token究竟区别在哪？如何进行身份认证，保持用户登录状态？】

---

## Day10 - 进程和线程的区别

**掌握程度：**
- 理解进程和线程在资源拥有、执行、上下文切换、创建和销毁开销方面的差异，能够清晰地描述进程和线程的定义、区别和联系
- 知道进程间通信和线程间通信的不同方式及其特点
- 如果有实际的多线程或多进程编程经验，能够结合实例讨论进程和线程的使用和最佳实践

**参考资料：**
- 【操作系统】进程和线程的区别
- 进程和线程的比较

---

## Day10 - 并行和并发有什么区别

**掌握程度：**
- 能够清晰地描述并发和并行的定义、区别和联系
- 理解并发和并行在实现、性能、应用场景和复杂性方面的差异

**参考资料：**
- 【一个视频告诉你"并发、并行、异步、同步"的区别】

---

## Day10 - 解释一下用户态和核心态

**掌握程度：**
- 能够清晰地描述用户态和核心态的定义、区别和它们在操作系统中的角色
- 理解用户态和核心态在特权级别、系统调用、安全性和性能方面的差异

---

## Day11 - 进程调度算法你了解多少

**掌握程度：**
- 能够清晰地描述至少几种常见的进程调度算法及其特点
- 知道在不同应用场景下如何选择适合的调度算法

**参考资料：**
- 进程调度算法
- 【操作系统】CPU调度算法】

---

## Day11 - 进程间有哪些通信方式

**面试中的掌握程度：**
- 能够清晰地描述至少几种常见的进程间通信方式及其特点
- 知道进程间通信在多任务操作系统中的应用，理解不同IPC机制的使用场景和限制
- 了解进程间通信可能带来的安全问题，如竞态条件、死锁等，并讨论如何避免这些问题

**参考资料：**
- 小林coding: 进程通信方式
- 【大厂面试笔试题31丨进程间通信方式】
- 『面试问答』：进程间通信的方式有哪些？

---

## Day11 - 解释一下进程同步和互斥，以及如何实现进程同步和互斥

**掌握程度：**
- 能够清晰地描述进程同步和互斥的定义、目的和区别
- 理解不同同步和互斥机制的工作原理和适用场景
  - 互斥锁：在访问共享资源前，进程必须先获取互斥锁，访问后再释放锁
  - 信号量：通过P（等待）和V（信号）操作来控制对共享资源的访问
- 知道如何使用常见的同步和互斥工具（如互斥锁、信号量、条件变量等）来实现进程同步和互斥

**参考资料：**
- 小林coding: 进程同步与互斥

---

## Day12 - 什么是死锁，如何预防死锁？

**掌握程度：**
- 理解死锁的危害，能够清晰地描述死锁的定义和四个必要条件
- 知道并能够解释常见的死锁预防策略
- 能够讨论死锁检测和恢复的机制
- 结合案例和并发编程讨论死锁的预防和处理

**参考资料：**
- 【面试问答：什么是死锁？，如何预防死锁】
- 小林coding: 如何避免死锁

---

## Day12 - 介绍一下几种典型的锁

**掌握程度：**
- 够清晰地描述每种锁的基本概念和用途
- 理解不同锁机制的适用场景和优缺点
- 知道如何根据实际需求选择合适的锁机制
- 了解不同锁机制对性能的影响，并能够讨论如何优化锁的使用
- 结合并发编程讨论锁的应用

**参考资料：**
- 小林coding: 什么是悲观锁，乐观锁

---

## Day12 - 讲一讲你理解的虚拟内存

**掌握程度：**
- 能够清晰地描述虚拟内存的定义和工作原理
- 理解虚拟内存如何通过页置换算法来管理内存
- 知道虚拟内存的优点和可能带来的性能问题

**参考资料：**
- 【操作系统】内存管理——虚拟内存】
- 小林coding: 虚拟内存

---

## Day13 - 你知道的线程同步的方式有哪些？

**掌握程度：**
- 清晰地描述每种线程同步机制的基本概念和用途
  - 互斥锁
  - 自旋锁
  - 读写锁
  - 条件变量
  - 信号量
- 理解不同同步机制的适用场景和优缺点
- 知道如何根据实际需求选择合适的线程同步机制

**参考资料：**
- 【多线程编程：一次性搞懂线程同步机制】
- 【『面试问答』：线程间同步方式有哪些？】

---

## Day13 - 有哪些页面置换算法

**掌握程度：**
- 能够清晰地描述至少几种常见的页面置换算法及其特点
- 理解不同页面置换算法的工作原理和适用场景

**参考资料：**
- 小林coding: 页面置换算法
- 【操作系统】10分钟-速解页面置换算法】

---

## Day15 - 熟悉那些 Linux 命令

**掌握程度：**
- 掌握关于文件操作，文件内容查看、权限管理、网络管理、进程管理、磁盘管理、软件包管理的一些常用命令，能够清晰地描述每个命令的基本用途和用法
- 理解不同命令在系统管理、文件操作、网络管理等方面的应用

**10分钟视频：**
- 【常用的Linux命令介绍：13个基本命令和Shell脚本编程】

---

## Day15 - 如何查看某个端口有没有被占用

**掌握程度：**
- 能够清晰地描述至少一种方法来检查端口是否被占用
- 理解不同工具的输出结果，知道如何根据输出判断端口的使用情况
- 如果有实际的网络问题排查经验，能够结合案例讨论如何使用命令

---

## Day15 - 说一下 select、poll 和 epoll 【重点】

**掌握程度：**
- 能够清晰地描述select、poll和epoll的定义和工作原理
- 理解它们在I/O多路复用中的应用和区别
- 知道它们各自的限制和适用场景

**参考资料：**
- Linux IO模式及 select、poll、epoll详解
- 推荐：深入学习IO多路复用 select/poll/epoll 实现原理

---

## Day16 - 一条 SQL 查询语句是如何执行的

**掌握程度：**
- 能够清晰地描述SQL查询的基本执行流程，包括解析、编译、优化、执行和返回结果
- 理解查询优化的重要性和基本原理

**参考资料：**
- 执行一条 select 语句，期间发生了什么？
- 【一条SQL查询语句是如何执行的？】
- 【MySQL 一条SQL的执行过程：彻底搞懂一条SQL的执行过程】

---

## Day16 - 事务的四大特性有哪些？

**掌握程度：**
- 能够清晰地描述事务的四大特性，并能够举例说明每个特性的含义和重要性
- 理解ACID属性如何确保数据库事务的可靠性和安全性
- 了解当前数据库管理系统在事务处理方面的最新研究和发展，例如多版本并发控制（MVCC）等

**参考资料：**
- 小林coding：事务四大特性

---

## Day16 - 数据库的事务隔离级别有哪些？

**掌握程度：**
- 能够清晰地描述每个事务隔离级别的定义和特点
- 理解不同隔离级别对脏读、不可重复读和幻读的影响
- 知道如何根据应用需求选择合适的事务隔离级别

**参考资料：**
- 事务隔离级别是怎么实现的？
- 【5分钟精通数据库，4种隔离级别的实现原理-事务的隔离性】

---

## Day17 - MySQL的执行引擎有哪些？

**掌握程度：**
- 至少回答出InnoDB和MyISAM这两种最常用的存储引擎及其特点，以及它们适用的场景，了解Memory、Archive等其他引擎及其使用场景
- 理解不同存储引擎在事务支持、锁定机制、性能和适用场景方面的差异
- 知道如何根据业务需求选择合适的存储引擎

**参考资料：**
- 【视频：MySQL有哪些存储引擎？】

---

## Day17 - MySQL为什么使用B+树来作索引【重点】

**掌握程度：**
- 能够清晰地描述B+树作为索引结构的优势和适用性
- 理解B+树如何提高数据库的查询效率和减少磁盘I/O
- 知道B+树如何支持高效的范围查询和事务处理

**参考资料：**
- 【视频：MySQL索引数据结构为什么使用B+树，我来告诉你】
- 小林coding: MySQL为什么使用B+数来做索引

---

## Day17 - 说一下索引失效的场景？

**掌握程度：**
- 能够清晰地描述至少几种索引失效的场景
- 理解索引失效的原因，以及它们对查询性能的影响
- 知道如何优化查询条件以利用索引

**参考资料：**
- 【视频：MySQL索引失效的底层原理，终于有人讲清楚了】
- 小林coding: 索引失效的场景

---

## Day18 - undo log、redo log、binlog 有什么用？

**掌握程度：**
- 理解每个日志的定义和作用：能够清晰地解释Undo Log、Redo Log和Binlog的基本功能
- 知道它们在事务处理中的角色：理解它们如何确保事务的ACID属性（原子性、一致性、隔离性、持久性）
- 了解它们在故障恢复中的应用：能够描述在系统故障时，这些日志如何帮助恢复数据
- 了解它们在数据库复制中的作用：知道Binlog在主从复制中的重要性

**参考资料：**
- 小林coding: undo log、redo log、binlog 有什么用？
- 【视频：undo log、redo log、 bin log的作用是什么？】

---

## Day18 - 什么是慢查询？原因是什么？可以怎么优化？

**掌握程度：**
- 能够清晰地定义慢查询：解释慢查询的概念及其对应用性能的影响
- 理解慢查询的常见原因：列举并解释导致慢查询的常见因素
- 知道优化慢查询的方法：描述几种常用的慢查询优化策略

**参考资料：**
- 【视频：如何做慢查询优化？】

---

## Day18 - MySQL 有哪些锁

**掌握程度**
- 能够清晰地定义各种锁类型和性质：解释表锁、行锁、间隙锁和意向锁的概念及其特点
- 理解锁的实现方式：描述悲观锁和乐观锁的实现机制
- 知道死锁的原因和解决方法：列举死锁产生的条件和避免死锁的策略
- 了解锁的优化方法：描述如何通过索引优化、事务管理和监控调优来提高数据库性能

**参考资料：**
- MySQL 有哪些锁？
- 【史上最全】MySQL各种锁详解：1小时彻底搞懂MySQL的各种锁】

---

## Day19 - MySQL和Redis的区别？

**掌握程度：**
- 能够清晰地描述MySQL和Redis的基本特性和区别
- 理解两者在存储方式、性能、数据结构和应用场景上的差异
- 知道在不同场景下选择MySQL或Redis的原因
- 结合项目讨论如何使用MySQL和Redis以发挥各自的优势

**参考资料：**
- Redis 介绍，为什么用 Redis 作为 MySQL 的缓存

---

## Day19 - Redis有什么优缺点？为什么用Redis查询会比较快

**掌握程度：**
- 能够清晰地描述Redis的主要优点：如速度快、支持多种数据结构、持久化等
- 理解Redis的缺点：如内存限制、数据持久化开销等
- 知道Redis查询速度快的原因：如内存存储、优化的数据结构、非阻塞I/O等
- 了解如何针对Redis进行性能优化

**参考资料：**
- 【视频：什么是 Redis，有什么优缺点？】
- 【视频：Redis刷题01：Redis为什么快？】

---

## Day20 - Redis的数据类型有那些？

**掌握程度：**
- 能够列举Redis支持的数据类型：至少列举上述数据类型中的5种
- 理解每种数据类型的特点和使用场景：例如，列表适用于实现队列，有序集合适用于排行榜
- 知道数据类型的内部实现：例如，列表的内部实现是一个双向链表，集合的内部实现是一个哈希表

**参考资料：**
- Redis 数据类型

---

## Day20 - Redis是单线程的还是多线程的，为什么？

**掌握程度：**
- 能够清晰地描述Redis的线程模型：说明Redis之前是单线程模型，6.0版本后引入了I/O多线程
- 理解单线程模型的原因：列举单线程模型的优点，如原子性操作、性能考虑等
- 知道Redis 6.0多线程的变化：描述引入I/O多线程的目的和效果

**参考资料：**
- Redis 线程模型

---

## Day20 - Redis 持久化机制有哪些？

**掌握程度：**
- 能够清晰地定义Redis的持久化机制：解释RDB和AOF的基本概念及其作用
- 理解RDB和AOF的优缺点：列举并解释RDB和AOF的特点，以及它们在数据安全性和性能方面的影响
- 知道触发持久化的方式：描述如何通过命令和配置文件触发RDB和AOF的持久化

**参考资料：**
- Redis 持久化机制

---

## Day22 - 介绍一下Redis缓存雪崩和缓存穿透，如何解决这些问题？

**掌握程度：**
- 能够清晰地定义缓存雪崩和缓存穿透。能够解释导致缓存雪崩和缓存穿透的原因
- 掌握解决方案：描述至少两种解决缓存雪崩和缓存穿透的策略。能够根据不同的业务场景选择最合适的解决方案

**参考资料：**
- 视频：【什么是Redis缓存雪崩、穿透、击穿，十分钟给你讲的明明白白】
- 什么是缓存雪崩、击穿、穿透？

---

## Day22 - 如何保证数据库和缓存的一致性

**掌握程度：**
- 能够解释为什么数据库和缓存的一致性
- 列举并解释在数据库和缓存同步过程中可能遇到的问题
- 描述至少三种以上保证数据库和缓存一致性的策略
- 够根据不同的业务场景选择最合适的一致性保证策略

**参考资料：**
- 【视频：数据库与缓存的数据一致性问题分析】
- 数据库和缓存如何保证一致性？

---

## Day23 - C++

### 静态变量和全局变量、局部变量的区别、在内存上是怎么分布的

**掌握程度：**
- 能够清晰地定义静态变量、全局变量和局部变量，解释它们的基本定义和特点
- 理解它们的区别：包括生命周期、作用域、内存分配和初始化
- 知道内存分布：描述它们在内存中的存储位置，如栈和数据段

**参考资料：**
- 菜鸟教程：C++ 全局变量、局部变量、静态全局变量、静态局部变量的区别

---

### 指针和引用的区别

**掌握程度：**
- 能够清晰地定义指针和引用：解释它们的基本定义和特点
- 理解它们的区别：包括定义方式、可变性、内存分配和内存管理
- 知道使用场景：描述指针和引用适用的不同编程场景

**参考资料：**
- 【为什么C++既有指针又有引用 | 指针和引用的区别 |】

---

### C++内存分区

**掌握程度：**
- 能够清晰地描述C++中的内存分区：包括栈、堆、全局/静态存储区、常量存储区、代码段、数据段和BSS段
- 理解各分区的特点和用途：解释每个内存分区的作用和存储的数据类型
- 知道内存分配和释放的机制：描述如何在栈和堆上分配和释放内存

**参考资料：**
- 博客：C++内存分区
- 【C++面试100问】第八十六问：内存分区模型是怎么做的？】

---

## Day23 - Java

### String、StringBuffer、StringBuilder的区别

**掌握程度：**
- 能够清晰地定义String、StringBuffer和StringBuilder：解释它们的基本定义和特点
- 理解它们的区别：包括不变性、线程安全性和性能
- 知道使用场景：描述String、StringBuffer和StringBuilder适用的不同编程场景

**参考资料：**
- JavaGuide: String、StringBuilder、StringBuffer的区别
- 【2分钟搞定八股文面试题】①String、StringBuffer、StringBuilder的区别】

---

### 接口和抽象类的区别

**掌握程度：**
- 能够清晰地定义接口和抽象类：解释它们的基本定义和特点
- 理解它们的区别：包括成员变量、方法实现、继承和实现方式
- 知道使用场景：描述接口和抽象类适用的不同编程场景

**参考资料：**
- 【每天一个技术点】抽象类和接口的异同】

---

### Java常见的异常类有哪些

**掌握程度：**
- 参考资料：
- 【阿里一面：Java中的异常类有哪些? 说说你常见的异常类 ？】

---

## Day23 - Python 测开

### 谈一谈你对测试的理解？你对测开这个岗位怎么理解的

1. **测试的目的：** 解释测试的主要目的是确保软件产品的质量，通过发现和修复缺陷来减少风险和成本
2. **测试的类型：** 概述不同类型的测试，如功能测试、性能测试、安全测试、回归测试等，并解释它们各自的重要性
3. **测试的生命周期：** 描述测试在软件开发生命周期中的作用，包括需求分析、测试计划、测试设计、执行和报告
4. **测试与开发的关系：** 阐述测试与开发是互补的过程，测试不仅仅是发现问题，也是帮助开发团队改进产品的过程
5. **测试的挑战：** 讨论测试过程中可能遇到的挑战，如时间限制、资源限制、复杂性管理等，并说明你如何面对这些挑战
6. **测试的重要性：** 强调在当今技术驱动的世界中，软件质量直接影响用户体验和业务成果，因此测试是至关重要的
7. **测试开发的角色：** 解释测试开发工程师是如何结合测试知识和软件开发技能，通过自动化测试、性能监控和持续集成等手段来提高测试效率和产品质量
8. **技术能力：** 讨论测试开发工程师需要具备的技术能力，包括编程、脚本编写、使用测试工具和框架等
9. **持续学习：** 表达你对测试领域新技术和方法的持续学习态度，以及适应快速变化的技术环境的能力
10. **沟通和协作：** 强调测试开发工程师需要与团队成员有效沟通，确保测试需求和结果被正确理解和实施

**参考资料：**
- 【说一下你对软件测试是怎么理解的】

---

### 为什么选择做测试/测开，而不是开发呢？

1. **职业兴趣：** 说明你对测试和质量保证的兴趣，以及这如何与你的个人技能和职业目标相匹配
2. **质量意识：** 表达你对确保软件质量的承诺，以及你认为测试是软件开发过程中不可或缺的一部分
3. **解决问题：** 强调你喜欢分析问题、设计测试用例和发现软件中的缺陷，这与开发工作解决问题的方式不同但同样重要
4. **技术多样性：** 说明你对学习多种技术和工具的兴趣，测试开发工程师通常需要掌握多种技能，这为你提供了更广泛的技术视野
5. **团队协作：** 描述你如何在团队中与开发人员、产品经理和其他利益相关者合作，以及这种协作如何帮助你更全面地理解软件开发过程
6. **持续学习：** 表达你对持续学习和适应新技术的热情，测试领域不断发展，提供了丰富的学习机会
7. **个人优势：** 指出你认为自己在测试方面的优势，比如对细节的关注、分析能力或沟通技巧
8. **实际经验：** 如果可能，分享一些你在测试或测试开发方面的实际经验，以及你从中学到的东西
9. **对开发的理解：** 表明你对开发工作也有尊重和理解，但你更倾向于测试，因为它更符合你的职业兴趣和技能

---

### 你觉得一个测试/测开应该具备哪些知识和能力？

**一个测试或测试开发工程师应该具备以下知识：**

1. **测试基础知识：** 了解软件测试的基本概念、原则和方法
2. **测试类型：** 熟悉不同类型的测试，如单元测试、集成测试、系统测试、性能测试、安全测试等
3. **测试流程：** 理解软件开发生命周期中测试的各个阶段和过程
4. **测试工具：** 掌握常用的测试工具，如缺陷跟踪系统（如JIRA）、自动化测试工具（如Selenium）、性能测试工具（如LoadRunner）等
5. **编程语言：** 具备至少一种编程语言的知识，如Java、Python
6. **数据库知识：** 了解SQL和数据库操作，因为测试经常涉及到数据验证
7. **操作系统：** 熟悉至少一种操作系统，如Windows、Linux或macOS，以及它们的命令行工具
8. **网络知识：** 理解基本的网络概念，如HTTP/HTTPS、TCP/IP、DNS等

**能力：**
- **分析和解决问题的能力：** 能够分析问题、设计测试用例，并从测试结果中识别问题
- **沟通能力：** 与开发团队、产品经理和其他利益相关者有效沟通
- **文档编写能力：** 能够编写清晰、详细的测试计划、测试用例和测试报告
- **持续学习：** 软件测试是一个不断发展的领域，需要持续学习新的工具和技术
- **批判性思维：** 能够从不同角度评估软件，识别潜在的风险和问题
- **细节关注：** 对细节敏感，能够发现软件中的小错误和不一致性
- **团队合作：** 能够在团队环境中有效工作，与他人协作以达成共同目标

**在面试中，至少应该能够回答到以下程度：**
- 列举并解释上述列出的关键知识和能力
- 提供实际例子，说明你如何在以前的工作中应用这些知识和技能
- 展示你对测试领域的热情和兴趣
- 表达你愿意学习和适应新技术的意愿
- 强调你的沟通和团队合作能力

---

## Day24 - C++

### static关键字和const关键字的作用

**掌握程度：**
- 能够清晰地定义static和const关键字：解释它们的基本定义和用途
- 理解static在不同上下文中的作用：包括静态变量、静态函数和静态存储期
- 理解const用于定义常量和保证数据不变性：包括常量变量、常量表达式、常量成员函数和类型限定
- 知道使用场景：描述static和const适用的不同编程场景

**参考资料：**
- c++面试专题】高频考点，介绍一下static和const

---

### 常量指针和指针常量之间有什么区别

**掌握程度：**
- 能够清晰地定义常量指针和指针常量：解释它们的基本定义和特点
- 理解它们的区别：包括可变性、使用场景和语法示例
- 知道使用案例：描述何时使用常量指针和指针常量

**参考资料：**
- 【C/C++细节06】辨析常量指针和指针常量】

---

### 结构体和类的区别

**掌握程度：**
- 能够清晰地定义结构体和类：解释它们的基本定义和特点
- 理解它们的设计意图和区别：包括访问权限、多态性、继承特性
- 知道使用场景：描述结构体和类适用的不同编程场景

**参考资料：**
- 【Cherno C++】【中字】C++类与结构体对比】
- 【动画教程】C语言中什么是结构体？带你透彻地了解它！so easy!】

---

## Day24 - Java

### 说一说Java面向对象三大特性

**掌握程度：**
- 能够清晰地定义封装、继承和多态：解释这三大特性的基本定义和目的
- 理解它们在Java中如何实现：描述Java语言中实现封装、继承和多态的具体语法和概念
- **设计模式：** 了解这三大特性在设计模式中的应用，如工厂模式、策略模式等

**参考资料：**
- JavaGuide: 面向对象三大特性

---

### 说一说你对Java多态的理解

**掌握程度：**
- 能够清晰地解释多态的定义，理解多态的实现方式：包括重载和重写的区别
- 知道多态的特性：解释动态绑定的概念，以及引用类型的统一和方法调用的统一性，能够讨论多态如何帮助提高代码的复用性、扩展性和解耦
- **设计模式：** 了解多态在设计模式中的应用，如模板方法模式、策略模式等

**参考资料：**
- JavaGuide: Java多态

---

### 重写和重载的区别

**掌握程度：**
- 能够清晰地定义重写和重载：解释它们的基本定义和使用目的
- 理解它们的区别：包括方法签名、使用范围、多态性、返回类型和构造方法
- 知道使用场景：描述重写和重载适用的不同编程场景

**参考资料：**
- JavaGuide: 重写和重载的区别

---

## Day24 - Python 测开

### 软件测试分为哪几个阶段？讲一下你们的测试流程

**参考资料：**
- 【干货】快速搞懂完整的软件测试流程！】

1. **需求分析：** 在这个阶段，测试团队参与需求收集和分析，确保需求文档的完整性，并识别潜在的测试需求
2. **测试计划：** 制定测试策略、测试计划和测试用例的设计，包括测试范围、资源、时间表和风险评估
3. **测试设计：** 根据需求文档设计测试用例和测试脚本，确保覆盖所有功能点和业务流程
4. **单元测试：** 开发人员在编码阶段完成后进行，主要关注单个模块或组件的功能是否按预期工作
5. **集成测试：** 多个模块或组件组合在一起进行测试，以确保它们能够协同工作
6. **系统测试：** 测试完整的、集成的软件系统以验证系统的符合性，包括功能、性能、安全性和可用性
7. **验收测试：** 通常由用户进行，以确定软件是否满足他们的业务需求和是否准备好投入生产环境
8. **性能测试：** 评估软件应用的速度、稳定性、资源消耗等性能指标，确保在高负载下仍能正常工作
9. **安全测试：** 专注于识别和修复安全漏洞，确保软件的安全性
10. **回归测试：** 当软件发生更改时进行，以确保新代码没有破坏现有的功能
11. **测试结束：** 测试完成后，进行测试报告的编写，包括测试结果、发现的问题以及推荐的改进措施

---

### 回归测试

回归测试是一种软件测试类型，旨在确保软件在经过修改或升级后，原有功能仍然按预期工作，并且新引入的更改没有引入新的错误。

1. **回归测试的定义：** 解释回归测试的目的，即验证软件更改没有破坏现有功能
2. **何时进行回归测试：** 说明在软件开发周期中，如代码更改、功能更新或修复bug后进行回归测试
3. **回归测试的类型：**
   - 完全回归测试：重新执行所有的测试用例
   - 部分回归测试：只执行影响的测试用例或关键功能
4. **如何执行回归测试：**
   - 确定测试范围：确定哪些功能或模块需要重新测试
   - 选择测试用例：选择或更新相关的测试用例来覆盖更改的部分
   - 执行测试：运行测试用例并记录结果
5. **回归测试的挑战：** 讨论如测试时间限制、资源限制、测试环境配置等问题
6. **回归测试策略：** 根据项目需求和风险评估，制定合适的回归测试策略
7. **个人经验：** 如果有，分享你过去在项目中执行回归测试的经验

---

## Day25 - C++

### new和molloc有什么区别，delete 和 free 有什么区别？

**掌握程度：**
- 能够清晰地定义new和malloc：解释它们的基本定义和用途
- 理解它们的区别：包括内存分配方式、类型安全性、构造函数调用、内存分配失败处理、内存释放方式、参数需求、自定义类型和重载、内存区域
- 知道使用场景：描述new和malloc适用的不同编程场景

**掌握程度：**
- 能够清晰地定义delete和free：解释它们的基本定义和用途
- 理解它们的区别：包括语言作用域、对象销毁、内存分配算法、类型安全、数组内存、返回值、内存泄漏
- 知道使用场景：描述delete和free适用的不同编程场景
- 内存泄漏和野指针：了解常见的内存错误，如内存泄漏和野指针，以及如何避免这些问题

**参考资料：**
- malloc free和new delete有什么区别问答？
- 【C++面试100问】第七问：new/delete与malloc/free的区别是什么？】

---

### 堆和栈的区别

**掌握程度：**
- 能够清晰地定义堆区和栈区：解释它们的基本定义和用途
- 理解它们的区别：包括内存管理、内存分配、内存大小、内存访问和内存生命周期
- 知道使用场景：描述堆区和栈区适用的不同编程场景

**参考资料：**
- 【C++面试100问】第十九问：堆与栈的区别是什么？（面试常考点）】
- 【烂大街的八股问题，堆与栈的区别

---

## Day25 - Java

### Java的集合类有哪些，那些是线程安全的，那些是线程不安全的

**掌握程度：**
- 能够列举Java中的主要集合类：包括List、Set、Map、Queue等
- 理解线程安全的概念：解释线程安全和线程不安全的区别
- 知道哪些集合是线程安全的：如Vector、Hashtable、ConcurrentHashMap等
- 知道哪些集合是线程不安全的：如ArrayList、HashSet、HashMap等，并了解如何使它们线程安全
- 了解Java并发包java.util.concurrent中的集合类，如BlockingQueue等
- 了解线程安全集合的性能影响，以及如何在性能和线程安全之间做权衡

**参考资料：**
- 【看动画，学Java集合教程】

---

### ArrayList 和 Array 有什么区别？ArrayList 和 LinkedList 的区别是什么？

**掌握程度：**
- 能够清晰地定义ArrayList、Array和LinkedList：解释它们的基本定义和特点
- 理解它们的区别：包括内存分配、性能、容量调整、线程安全和功能丰富性
- 知道使用场景：描述ArrayList、Array和LinkedList适用的不同编程场景
- 源码理解：对ArrayList和LinkedList的内部实现有一定的了解

**参考资料：**
- 黑马面试题解析

---

### ArrayList的扩容机制

**掌握程度：**
- 能够清晰地描述ArrayList扩容的触发条件和扩容因子
- 理解扩容的步骤和性能影响
- 知道如何优化ArrayList的使用，减少不必要的扩容
- 源码理解：对ArrayList扩容的源码有一定的了解

**参考资料：**
- 【java常问面试题】网易一面：ArrayList的自动扩容机制了解吗？】

---

## Day25 - 测开

### 功能测试用例一般包含哪些内容

1. **用例标识：** 唯一标识符，如用例ID
2. **用例标题：** 简短描述测试用例的目的
3. **测试目的：** 测试用例的目标或意图
4. **前提条件：** 执行测试用例前必须满足的条件
5. **测试步骤：** 详细的操作步骤，指导如何执行测试
6. **测试数据：** 用于执行测试的具体数据或数据生成方法
7. **预期结果：** 执行测试步骤后预期的输出或行为
8. **实际结果：** 在测试执行过程中实际观察到的输出或行为（在测试执行后填写）
9. **测试状态：** 标识测试用例的状态，如通过、失败、阻塞等
10. **测试环境：** 测试用例执行的软件和硬件环境
11. **测试版本：** 被测试软件的版本信息
12. **执行者：** 执行测试用例的测试人员
13. **执行日期：** 测试用例执行的日期
14. **备注/特殊说明：** 对测试用例的额外说明或注意事项
15. **缺陷标识：** 与测试用例相关的缺陷编号或链接
16. **优先级：** 测试用例的重要性或紧急性等级
17. **回归标记：** 是否需要在后续版本中重新执行此用例

---

### 说一下设计测试用例有哪些方法

1. **等价类划分：** 将输入数据划分为有效等价类和无效等价类，确保测试用例覆盖所有可能的输入情况
2. **边界值分析：** 测试输入或输出值的边界情况，包括正常边界和异常边界
3. **决策表测试：** 使用表格形式列出各种输入条件和对应的预期行为，以确保所有可能的条件组合都被测试
4. **状态转换测试：** 针对具有状态的系统，测试状态之间的转换是否正确
5. **错误推测法：** 基于错误的假设来设计测试用例，以发现可能的缺陷
6. **随机测试：** 随机生成测试数据和操作步骤，用于探索性测试
7. **场景法：** 模拟用户使用场景来设计测试用例，确保测试覆盖实际使用情况
8. **正交数组测试：** 使用正交表来设计测试用例，确保测试用例能够覆盖多个参数的组合
9. **组合测试：** 基于参数值组合来设计测试用例，以发现参数交互引起的缺陷
10. **性能测试设计：** 特别针对系统性能的测试用例设计，包括负载、压力和稳定性测试
11. **安全性测试设计：** 针对系统安全性的测试用例设计，包括认证、授权、数据加密等
12. **回归测试设计：** 在软件更新后，设计测试用例以确保新代码没有破坏现有功能

**在面试中，你应该能够：**
- 清晰地解释每种方法的基本概念和应用场景
- 举例说明你如何在实际工作中应用这些方法
- 展示你如何根据需求的复杂性和测试目标选择适当的测试设计方法
- 讨论这些方法的优缺点，以及它们在不同情况下的适用性

---

## Day26 - C++

### 什么是智能指针，C++有哪几种智能指针

**掌握程度：**
- 能够清晰地定义智能指针：解释智能指针的基本定义和目的
- 列举C++中的智能指针类型：至少提到std::unique_ptr、std::shared_ptr和std::weak_ptr
- 理解每种智能指针的特点和使用场景：
  - std::unique_ptr适用于所有权唯一的场景
  - std::shared_ptr适用于多个指针共享对象的场景
  - std::weak_ptr适用于解决循环引用问题

**参考资料：**
- 第 5 章 智能指针与内存管理 现代 C++ 教程: 高速上手 C++

---

### 智能指针的实现原理是什么

**掌握程度：**
- 能够描述智能指针的一般实现原理：包括控制块、构造函数、拷贝/移动构造函数、赋值运算符和析构函数
- 理解引用计数机制：特别是对于std::shared_ptr的实现
- 知道智能指针如何管理资源：包括自定义删除器的使用和空指针检查

**参考资料：**
- 万字长文全面详解现代C++智能指针：原理、应用和陷阱

---

## Day26 - Java

### final关键字有什么作用

**掌握程度：**
- 能够清晰地定义final关键字：解释它用于创建不可变变量、常量、限制方法覆盖和限制类继承
- 理解final关键字的使用场景：包括数据保护、常量定义、方法和类的最终性
- 知道使用final关键字的好处：如提高代码的可读性和可维护性，保护对象的状态不受子类影响

**参考资料：**
- javaguide：final关键字总结

---

### java 中 == 和 equals 的区别

**掌握程度：**
- 能够清晰地定义==和equals：解释它们的基本定义和用途
- 理解它们的区别：包括比较内容、默认行为、可覆盖性和使用场景

**参考资料：**
- JavaGuide: ==和equals的区别

---

## Day26 - 测开

### 你对单元测试和集成测试有哪些了解

#### 单元测试

**定义：** 单元测试是针对最小的可测试部分（通常是函数或方法）的测试。它主要用于验证代码的每个单元是否按预期工作。

**关键点：**
- **测试目的：** 确保每个单元的逻辑正确，没有错误
- **测试范围：** 单个函数、方法或类
- **测试执行者：** 通常由开发人员执行
- **测试自动化：** 单元测试通常自动化，易于重复执行
- **测试时机：** 开发过程中编写代码的同时进行
- **测试覆盖率：** 目标是高覆盖率，理想情况下达到100%

#### 集成测试

**定义：** 集成测试是在单元测试之后进行的，目的是检查多个单元或组件在一起工作时是否符合设计。

**关键点：**
- **测试目的：** 确保组件间的接口和交互按预期工作
- **测试范围：** 多个单元或模块的组合
- **测试执行者：** 可以是开发人员或专门的测试人员
- **测试自动化：** 可能部分自动化，但可能需要手动干预
- **测试时机：** 所有或大部分单元测试完成后进行
- **测试覆盖率：** 目标是覆盖所有重要的交互路径

**在面试中，你应该至少达到以下程度：**
1. 理解区别：清晰地描述单元测试和集成测试的区别
2. 测试重要性：解释为什么这两种测试对软件质量至关重要
3. 测试实践：讨论你在实际项目中如何执行这两种测试
4. 测试工具：提及你使用过的单元测试和集成测试工具（如JUnit、TestNG、PyTest等）
5. 测试策略：描述你如何为项目制定单元测试和集成测试策略
6. 测试覆盖率：解释测试覆盖率的重要性以及如何提高它

---

### 系统测试和集成测试的区别和使用场景是什么

#### 系统测试

**定义：** 系统测试是验证整个系统的功能和性能是否符合用户需求和系统规格说明的测试。

**关键点：**
- **测试目的：** 确保系统作为一个整体满足所有业务需求和性能要求
- **测试范围：** 整个应用程序或系统
- **测试执行者：** 通常由独立的测试团队执行，以确保客观性
- **测试内容：** 包括功能测试、性能测试、安全性测试、可用性测试等
- **测试时机：** 在集成测试之后，所有模块已经集成并经过测试后进行

#### 集成测试

**定义：** 集成测试是检查多个单元或组件在合并后作为一个整体是否按预期工作的测试。

**关键点：**
- **测试目的：** 确保组件间的接口和交互按预期工作，发现在单个组件测试中未发现的问题
- **测试范围：** 两个或多个已经测试的单元的组合
- **测试执行者：** 可以是开发人员或测试人员
- **测试内容：** 主要关注组件间的接口和数据流
- **测试时机：** 在单元测试之后，各个单元或模块开发完成并集成在一起时进行

**区别和使用场景**
- **目标不同：** 系统测试关注整个系统的行为，而集成测试关注组件间的交互
- **测试范围不同：** 系统测试是更宏观的测试，集成测试是更微观的，关注部分的整合
- **执行时机不同：** 集成测试通常在单元测试之后、系统测试之前进行
- **测试数据：** 系统测试可能使用真实或接近真实的数据，集成测试可能使用模拟或桩数据
- **测试环境：** 系统测试可能在更接近生产环境的条件下执行，集成测试可能在开发或模拟环境中执行

---

### 什么是黑盒测试和白盒测试

#### 黑盒测试

**定义：** 黑盒测试是一种测试方法，测试者不需要了解程序内部的逻辑和结构，只关注输入和输出之间的关系。

**关键点：**
- **测试基础：** 基于需求规格说明
- **测试方法：** 通过测试不同的输入来观察输出是否符合预期
- **关注点：** 功能测试，不考虑内部实现
- **使用场景：** 适用于系统测试、验收测试等

#### 白盒测试

**定义：** 白盒测试是一种测试方法，测试者需要了解程序的内部结构和逻辑，以便设计测试用例来覆盖代码的各个部分。

**关键点：**
- **测试基础：** 基于代码和内部逻辑
- **测试方法：** 设计测试用例来覆盖所有或关键的代码路径、分支、循环等
- **关注点：** 代码覆盖率，确保代码的每个部分都被测试
- **使用场景：** 适用于单元测试、集成测试等

**在面试中，你应该至少达到以下程度：**
1. 准确定义：能够清晰地定义黑盒测试和白盒测试
2. 理解差异：解释两种测试方法的主要区别
3. 适用场景：描述在什么情况下使用黑盒测试或白盒测试
4. 测试技术：提及与黑盒和白盒测试相关的技术和方法，如等价类划分、边界值分析、路径覆盖等

---

### 说一下等价类划分和边界值分析法

#### 等价类划分

**定义：** 等价类划分是一种测试设计技术，它将输入数据划分为多个等价类，每个等价类中的值对于揭露程序中的错误来说是等效的。

**关键点：**
- **有效等价类：** 在这些类中的测试用例预期会得到正确的结果
- **无效等价类：** 设计用来检测程序的错误承受能力，预期可能得到错误的结果
- **测试用例选择：** 通常选择一个有效等价类和一个无效等价类作为测试用例

#### 边界值分析

**定义：** 边界值分析是一种测试设计技术，它专注于输入域或输出域的边界值，因为这些地方更容易出现错误。

**关键点：**
- **正常边界：** 正常操作的边界条件，例如数组的最小和最大索引
- **异常边界：** 超出正常操作范围的边界条件，用于测试程序的错误处理能力
- **测试用例选择：** 包括边界值本身以及边界值的相邻值

---

## Day27 - 什么是内存泄漏, 如何检测和防止？

**掌握程度：**
- 能够清晰地定义内存泄漏：解释内存泄漏的概念及其对程序的影响
- 理解内存泄漏的常见原因：列举并解释导致内存泄漏的常见因素
- 知道如何检测和防止内存泄漏：描述使用工具和编码实践来检测和预防内存泄漏的方法

**参考资料：**
- 【C++面试100问】第六问：内存泄漏是什么，有哪几种，怎么解决？】

---

## Day27 - 什么是野指针？如何避免？

**掌握程度：**
- 能够清晰地定义野指针：解释野指针的概念及其可能造成的影响
- 理解野指针的产生原因：列举并解释导致野指针的常见情况
- 知道如何避免野指针：描述使用初始化、智能指针、RAII 机制等方法来预防野指针

**面试题：**
- 如何避免野指针？

---

## Day27 - Java中的HashMap了解吗？HashMap 的底层实现是什么?

**掌握程度：**
- 能够清晰地描述HashMap的工作原理和内部数据结构
- 理解HashMap的线程安全性问题和扩容机制
- 知道如何优化HashMap的性能
- 了解HashMap与HashTable的区别
- 源码理解：对HashMap的源码实现有一定的了解

**参考资料：**
- 黑马：HashMap面试题解析
- https://mp.weixin.qq.com/s/gJXv3x-yGkG8IT97hZvWvQ
- 【Java连环面试题】HashMap是如何解决hash冲突的？它与HashTable的区别是啥？你抗的住吗？】
- 【HashMap源码分析】

---

## Day27 - 测开

### 如何写测试用例

1. **理解需求：** 能够说明如何从需求文档中提取测试点
2. **测试用例的结构：** 能够描述一个测试用例的基本组成部分，如测试用例ID、标题、目的、前提条件、测试步骤、预期结果、实际结果等
3. **测试用例的设计方法：** 能够讨论不同的测试用例设计技术，如等价类划分、边界值分析、错误推测法、场景法等
4. **测试数据的选择：** 能够说明如何选择或生成测试数据来满足测试用例的需要
5. **测试条件的覆盖：** 能够展示如何确保测试用例覆盖正常和异常的测试条件
6. **测试用例的优先级：** 能够讨论如何根据风险、严重性和测试进度等因素确定测试用例的优先级
7. **测试用例的可执行性：** 能够说明测试用例需要清晰、具体，以便于执行和重现
8. **测试用例的评审和更新：** 能够讨论测试用例的评审过程以及如何根据需求变更更新测试用例
9. **自动化测试用例：** 能够讨论哪些测试用例适合自动化，以及自动化测试用例的设计要点
10. **测试用例的文档化：** 能够说明测试用例的文档化重要性，以及如何维护测试用例的版本控制
11. **测试用例与测试策略的一致性：** 能够展示测试用例如何与整体测试策略和目标保持一致

---

### 如何提高用例的覆盖率，减少漏测

1. **全面的需求理解：** 能够说明如何基于完整和详细的需求来设计测试用例
2. **多种测试设计技术：** 能够讨论使用等价类划分、边界值分析、决策表测试、状态转换测试、场景法等方法来提高覆盖率
3. **代码覆盖率工具：** 能够讨论如何使用代码覆盖率工具来识别未测试到的代码路径，并据此补充测试用例
4. **探索性测试：** 能够说明如何结合探索性测试来发现潜在的漏测区域
5. **风险驱动的测试：** 能够展示如何根据风险评估来优先测试关键功能和高风险区域
6. **持续的回归测试：** 能够讨论回归测试的重要性以及如何通过自动化回归测试来保持高覆盖率
7. **测试数据管理：** 能够说明如何有效地管理测试数据，以确保覆盖各种输入场景
8. **缺陷跟踪和分析：** 能够讨论如何通过缺陷跟踪和分析来识别测试用例的不足，并进行改进
9. **团队协作：** 能够展示团队成员如何协作，共享测试想法和测试用例，以提高覆盖率
10. **测试自动化：** 能够讨论自动化测试在提高测试覆盖率和减少重复工作方面的作用
11. **测试用例的持续评审和优化：** 能够说明如何定期评审和优化测试用例，以确保它们仍然相关和有效
12. **利用用户反馈：** 能够讨论用户反馈如何帮助识别测试过程中可能遗漏的使用场景

---

### 测试报告应该包含哪些内容？

1. **测试报告标题：** 报告的名称，通常包括项目名称和报告类型
2. **版本信息：** 测试报告的版本号，以及相关软件和文档的版本号
3. **测试目的：** 简要说明测试的目标和目的
4. **测试环境：** 描述测试执行的硬件、软件、网络环境等
5. **测试策略和方法：** 概述测试的策略和采用的测试方法
6. **测试用例执行摘要：** 测试用例的执行情况，包括执行数量、通过/失败比率等
7. **缺陷统计：** 缺陷的总数、严重性分布、状态（如已解决、待解决、延期等）
8. **关键发现：** 测试过程中发现的主要问题和关键缺陷
9. **测试结果分析：** 对测试结果的分析，包括覆盖率、性能指标等
10. **风险评估：** 基于测试结果对软件质量和风险的评估
11. **测试结论：** 测试团队对软件当前状态的总结性评价
12. **改进建议：** 针对发现的问题和测试过程的改进建议
13. **附件和参考资料：** 测试过程中使用的附加文档或参考资料
14. **测试团队信息：** 参与测试的团队成员和他们的职责
15. **测试时间线：** 测试活动的开始和结束日期
16. **问题解决状态：** 已解决和未解决问题的列表，以及它们的解决状态

---

## Day29 - C++

### C++面向对象三大特性

**掌握程度：**
- 能够清晰地定义封装、继承和多态：解释这三大特性的基本定义和目的
- 理解它们在C++中如何实现：描述C++中实现封装、继承和多态的具体语法和概念
- **设计原则：** 了解面向对象设计原则，如单一职责原则、开闭原则等

**参考资料：**
- 【C++面试题】面对对象的三大特征及特性】

---

### 简述一下 C++的重载和重写，以及它们的区别和实现方式

**掌握程度：**
- 能够清晰地定义重载和重写：解释它们的基本定义和目的
- 理解它们的区别：包括作用域、参数列表、返回类型、虚函数和动态绑定
- 知道实现方式：描述如何在C++中实现重载和重写
- **多态性：** 了解重载和重写在实现多态性中的作用

**参考资料：**
- 【C++面试题】面试官：请简述多态实现的原理】

---

## Day29 - Java

### HashMap 为什么是线程不安全的? 如何实现线程安全

**参考资料：**
- 【字节一面：HashMap 是线程安全的吗 ？在多线程环境下会有什么问题 ？】

**掌握程度：**
- 能够清晰地解释HashMap在多线程环境下不安全的原因
  - **扩容死循环（JDK 1.7）:** 在多线程环境下，HashMap扩容时可能会形成环形链表，导致死循环
  - **数据覆盖（JDK 1.8）:** 多线程同时进行put操作时，可能会覆盖彼此的数据，因为新元素总是插入到链表的头部
- 知道如何在多线程环境下使用HashMap的线程安全策略
  - 使用Hashtable（已废弃）: Hashtable通过在所有方法上使用synchronized关键字来保证线程安全，但效率较低
  - 使用ConcurrentHashMap: ConcurrentHashMap是线程安全的HashMap替代品，提供了更高的并发性能
  - 使用Collections.synchronizedMap: 通过Collections工具类的synchronizedMap方法将HashMap包装成线程安全的Map
  - 手动同步代码块: 在访问HashMap时使用同步代码块来确保线程安全
  - 使用ReadWriteLock: 使用读写锁来允许多个读操作并发执行，写操作则需要独占锁
- **性能优化:** 了解不同线程安全策略对性能的影响，并能够根据场景选择最合适的策略
- **并发工具:** 了解Java并发工具包中的其他并发集合类，如ConcurrentLinkedQueue、BlockingQueue等

---

### concurrentHashMap 如何保证线程安全

### HashMap和ConcurrentHashMap的区别

**掌握程度：**
- 能够清晰地描述ConcurrentHashMap的线程安全机制
- 理解不同JDK版本下ConcurrentHashMap的实现差异
- 知道CAS操作、volatile、synchronized、Unsafe类和LongAdder类在ConcurrentHashMap中的应用
- 源码理解：对ConcurrentHashMap的源码实现有一定的了解

**参考资料：**
- 【Java面试】 如何高分回答，ConcurrentHashMap是如何保证线程安全？这道面试题的】
- 【从底层结构、原理、扩容机制，到深入源码，讲穿HashMap和ConcurrentHashMap】

---

## Day30 - Java

### HashSet 和 HashMap 的区别

**掌握程度：**
- 能够清晰地描述HashMap和HashSet的基本区别
- 理解它们的存储内容、查询性能、实现原理、遍历方式和使用场景
- 知道线程安全性问题以及如何解决

**参考资料：**
- 【Java面试突击15：HashMap 和 HashSet 有什么区别？】

---

### HashMap 和 HashTable 的区别

**掌握程度：**
- 理解线程安全性的重要性，熟悉HashMap的非线程安全行为。能够举例说明在多线程环境下使用HashMap可能导致的问题，例如数据覆盖或丢失。了解HashTable的线程安全机制: 能够描述HashTable如何通过内部同步机制（例如synchronized关键字）来确保线程安全
- **其他要点**
  - 掌握null键和null值的处理: 能够清晰地指出HashMap允许使用null键和null值，而HashTable不允许
  - 了解继承关系和接口实现: 能够解释HashMap和HashTable继承的不同类，以及它们实现的不同接口
  - 熟悉遍历性能和并发控制: 能够比较两者在遍历过程中的性能，以及它们如何处理并发修改
- **选择适当的使用场景:** 能够根据具体应用需求推荐使用HashMap或HashTable，考虑线程安全、性能和易用性
- **性能优化策略:** 了解并能够讨论针对HashMap和HashTable的性能优化技巧，例如初始化容量的设置、负载因子的选择等
- **源码分析能力:** 如果对HashMap和HashTable的源码有一定了解，能够讨论它们的内部实现差异
- **替代方案的了解:** 了解并能够讨论其他线程安全的Map实现，如ConcurrentHashMap，以及它们与HashTable相比的优势

**参考资料：**
- 【Java面试最新】HashMap与HashTable有什么区别？】

---

## Day30 - C++

### c++如何实现 多态

**掌握程度：**

1. **理解多态的概念：**
   - 多态是一种允许同一个接口接受不同的数据类型的特性
   - 它允许程序在运行时根据对象的实际类型调用相应的函数

2. **掌握虚函数的实现细节：**
   - 能够解释虚函数如何允许派生类重写基类的行为
   - 知道虚函数的声明方式，以及它们是如何在基类中使用virtual关键字的

3. **理解纯虚函数和抽象类：**
   - 能够区分纯虚函数和虚函数，以及它们在类设计中的作用
   - 能够解释为什么一个包含纯虚函数的类是抽象类，以及为什么这样的类不能被实例化

4. **理解动态绑定：**
   - 能够解释动态绑定（Dynamic Binding）是在程序运行时确定函数调用的过程，而静态绑定（Static Binding）是在编译时确定的

5. **讨论多态在设计模式中的应用：**
   - 如果可能，讨论多态在设计模式（如工厂模式、策略模式等）中的应用

6. **讨论多态的局限性和最佳实践：** 讨论多态可能带来的问题，例如性能开销（虚函数表的查找）

7. **理解多态与继承的关系：** 能够解释多态是如何依赖于继承的，以及它们是如何共同工作来实现面向对象的设计

8. **理解C++中的其他多态形式：**
   - 了解除了虚函数之外的其他多态形式，例如运算符重载、模板等

**参考资料：**
- 【C++面试题】面试官：请简述多态实现的原理】

---

### 虚函数和纯虚函数的区别

**掌握程度：**

1. **理解虚函数和纯虚函数的基本概念：**
   - 虚函数是基类中声明的成员函数，可以在派生类中被重写（Override），允许通过基类指针或引用调用派生类版本的函数
   - 纯虚函数是基类中声明但没有实现的成员函数，通过在声明末尾添加= 0来标识，强制要求派生类提供实现

2. **掌握虚函数和纯虚函数的作用：**
   - 虚函数允许实现运行时多态，即动态绑定，而纯虚函数用于定义接口规范，强制派生类实现特定行为

3. **理解抽象类的概念：**
   - 包含至少一个纯虚函数的类称为抽象类，不能被实例化

4. **区分虚函数和纯虚函数在类设计中的使用场景：**
   - 虚函数适用于基类提供一个通用的实现，而派生类可能需要定制化行为的情况
   - 纯虚函数适用于基类中那些必须由派生类实现的行为，基类无法提供有意义的实现

5. **了解虚析构函数的重要性：**
   - 基类的析构函数应当是虚函数，以确保通过基类指针删除派生类对象时，能够正确地调用派生类的析构函数，避免内存泄漏

6. **理解多态的实现原理：**
   - 多态的实现涉及到虚函数表（vtable）和虚函数指针（vptr），了解这些机制如何在C++中工作

7. **讨论虚函数和纯虚函数的语法和实现细节：**
   - 能够讨论虚函数和纯虚函数的声明、定义，以及它们在类继承体系中的作用

**参考资料：**
- 【 C++面试题之-虚函数与纯虚函数的区别】
- 【C++面试100问】第五十五问：请分别介绍一下STL的所有容器，说说vector是如何扩容的，迭代器删除如何避免失效问题？】

---

## Day31 - C++

### 什么是构造函数和析构函数？构造函数、析构函数可以是虚函数嘛

**参考资料：**
- 【构造函数与析构函数】
- 【C++多态中析构函数为什么要写成虚函数？（答案见简介）】

---

### c++构造函数有几种，分别什么作用

**掌握程度：**

1. **默认构造函数：** 没有参数的构造函数，用于创建对象时初始化成员变量为默认值
2. **参数化构造函数：** 带有参数的构造函数，允许在创建对象时初始化成员变量为特定值
3. **拷贝构造函数：** 以同一类型的对象作为参数的构造函数，用于创建一个对象的副本
4. **移动构造函数：** 以右值引用作为参数的构造函数，用于在不进行拷贝的情况下接收资源，通常用于优化性能
5. **转换构造函数：** 允许将其他类型转换为当前类型的对象，实现类型转换
6. **委托构造函数：** 一个构造函数调用同一个类中的另一个构造函数来完成初始化
7. **初始化列表构造函数：** 使用成员初始化列表来初始化成员变量的构造函数，是C++中推荐的初始化成员变量的方式
8. **私有/保护构造函数：** 将构造函数设置为私有或保护，以限制外部直接创建类的对象，常用于单例模式或防止外部继承
9. **继承构造函数（C++11引入）：** 基类可以声明构造函数为final，防止派生类重写构造函数

**在面试中，你应该能够：**
- 解释每种构造函数的作用和使用场景。讨论构造函数在类设计中的重要性，如初始化、对象创建等
- 讨论构造函数与析构函数的关系，以及它们在对象生命周期中的角色
- 讨论构造函数的特殊特性，如拷贝构造函数的浅拷贝与深拷贝问题

---

## Day31 - Java

### 你知道Java中有哪些锁吗

**掌握程度：**

1. **Synchronized锁：**
   - 能够解释synchronized关键字在Java中的作用，它是实现方法或代码块同步的基本关键字
   - 知道synchronized可以用于修饰方法或代码块，并且可以用于实现对象锁或类锁

2. **ReentrantLock（可重入锁）：**
   - 能够描述ReentrantLock是Java java.util.concurrent.locks包下的一个锁接口，提供了与synchronized类似的功能，但比synchronized更灵活
   - 知道如何使用ReentrantLock，包括尝试非阻塞获取锁、尝试超时获取锁、公平性选择等

3. **ReadWriteLock（读写锁）：**
   - 能够解释ReadWriteLock允许多个读操作同时进行，但写操作是排他的
   - 知道ReadWriteLock由ReentrantReadWriteLock类实现，并且适用于读多写少的场景

4. **StampedLock：**
   - 能够描述StampedLock是Java 8引入的，相比ReadWriteLock，它提供了更多的操作模式，比如乐观读、悲观读等

5. **显式锁和隐式锁：**
   - 能够区分显式锁（如ReentrantLock）和隐式锁（如synchronized）的区别

6. **偏向锁、轻量级锁和重量级锁：**
   - 能够解释Java虚拟机在实现synchronized时可能采用的几种锁优化策略

7. **条件锁（Condition）：**
   - 能够描述与Lock接口配合使用的Condition接口，它允许线程在某些条件下等待或唤醒

8. **分布式锁：**
   - 如果有相关经验，能够讨论在分布式系统中如何实现锁，例如使用Redis的RedLock算法

**在面试中，你应该能够：**
- 清晰地解释上述锁的基本概念和使用场景
- 讨论各种锁的优缺点，以及它们在并发编程中的应用

**参考资料：**
- 【10分钟彻底搞懂Java中的各种锁，】

---

### 说一说你对 synchronized 的理解

**掌握程度：**

1. **基本作用：**
   - 能够解释 synchronized 用于线程间的互斥，防止多个线程同时执行特定代码段

2. **使用方式：**
   - 知道 synchronized 可以修饰方法或代码块
   - 能够区分 synchronized 修饰静态方法和非静态方法的区别，以及它们分别锁定的对象

3. **锁的获取与释放：**
   - 能够描述 synchronized 在进入同步代码块时获取锁，在退出时释放锁的过程

4. **可重入性：**
   - 知道 synchronized 是可重入的，同一线程可以多次获取同一个锁

5. **锁的粒度和性能：**
   - 了解 synchronized 可能导致的性能问题，如锁竞争和线程阻塞
   - 知道如何通过减少锁的范围来提高性能

6. **锁的可见性：**
   - 能够解释 synchronized 保证了内存的可见性，即一个线程对共享变量的修改对其他线程是可见的

7. **与 volatile 的比较：**
   - 能够区分 synchronized 和 volatile 的使用场景和保证的内存语义

8. **锁优化：**
   - 了解JVM对 synchronized 进行的一些锁优化措施，如锁粗化、锁消除、轻量级锁、偏向锁等

9. **其他同步工具的对比：**
   - 能够比较 synchronized 与 ReentrantLock、ReadWriteLock 等其他同步工具的区别和使用场景

**在面试中，你应该能够：**
- 清晰地解释 synchronized 的作用和工作原理
- 讨论 synchronized 的使用方式和最佳实践
- 讨论 synchronized 的局限性和潜在问题，如死锁和性能影响
- 对比其他同步机制，并讨论 synchronized 的适用场景

**参考资料：**
- 【大厂面试】聊聊你对Synchronized的理解】
- 黑马程序员 Java面试题解析

---

## Day32 - C++

### STL 容器了解那些

**掌握程度：**

1. **序列容器（Sequential Containers）:**
   - vector：动态数组，可以快速随机访问
   - deque：双端队列，提供在首尾两端快速插入和删除的能力
   - list：双向链表，提供在任意位置快速插入和删除的能力
   - forward_list：单向链表，提供在头部或指定位置快速插入和删除的能力

2. **关联容器（Associative Containers）:**
   - set：基于红黑树的集合，保证元素唯一性
   - multiset：允许多个相同元素的集合
   - map：基于红黑树的键值对集合，保证键的唯一性
   - multimap：允许键的重复
   - unordered_set 和 unordered_multiset：基于哈希表的集合
   - unordered_map 和 unordered_multimap：基于哈希表的键值对集合

3. **容器适配器（Container Adapters）:**
   - stack：后进先出（LIFO）的栈
   - queue：先进先出（FIFO）的队列
   - priority_queue：优先队列，元素按照优先级排序

4. **位容器（Bitwise Containers）:**
   - bitset：固定长度的位集合
   - dynamic_bitset：可变长度的位集合

5. **元组（Tuples）:**
   - tuple：固定大小的异构元素序列
   - pair：包含两个元素的元组

6. **算法容器（Algorithms）:**
   - 虽然不是容器，但STL提供了大量通用算法，如排序、搜索、复制等，它们可以操作容器

**在面试中，你应该能够：**
- 解释上述STL容器的基本特性和用途
- 讨论不同容器的时间复杂度，特别是对于插入、删除和访问操作
- 举例说明如何在实际编程中选择合适的STL容器
- 讨论STL容器的线程安全性和同步问题
- 了解STL容器的底层实现，如 vector 的动态扩容机制，map 的红黑树实现等

**参考资料：**
- 【C++面试100问】第五十五问：请分别介绍一下STL的所有容器，说说vector是如何扩容的，迭代器删除如何避免失效问题？】

---

### 深拷贝与浅拷贝的区别

**掌握程度：**

1. **浅拷贝（Shallow Copy）:**
   - 浅拷贝仅复制对象的顶层数据，对于对象内部的指针成员，浅拷贝只是复制了指针的值，不会递归地复制指针指向的内存内容
   - 因此，如果对象中包含指针，浅拷贝会导致多个对象拥有相同的内存地址

2. **深拷贝（Deep Copy）:**
   - 深拷贝会递归地复制对象的所有成员，包括指针成员指向的内存内容，确保新对象获得所有数据的独立副本
   - 对于指针成员，深拷贝会分配新的内存，并复制原指针指向的数据到新内存中

3. **拷贝构造函数:**
   - 如果类中有指针成员，需要明确指定拷贝构造函数的行为，以区分是深拷贝还是浅拷贝
   - 默认情况下，如果用户没有定义拷贝构造函数，编译器会生成一个浅拷贝的版本

4. **赋值操作符重载:**
   - 同样地，赋值操作符也需要重载以处理深拷贝或浅拷贝的问题

5. **内存管理:**
   - 浅拷贝可能导致内存泄漏，因为复制的对象可能无法正确地释放它们共享的内存
   - 深拷贝需要确保复制的对象能够独立地管理自己的内存，包括分配和释放

6. **使用场景:**
   - 浅拷贝适用于对象中不包含或只包含浅拷贝安全的指针成员的情况
   - 深拷贝适用于对象中包含指针成员，且需要完全独立的对象副本的情况

**在面试中，你应该能够：**
- 清晰地解释深拷贝和浅拷贝的区别
- 讨论它们各自的使用场景和潜在问题
- 讨论深拷贝和浅拷贝对内存管理的影响

**参考资料：**
- 【【C++面试100问】第十八问：深拷贝与浅拷贝是什么？（面试常考点）】 https://www.bilibili.com/video/BV1WV4y1a7Jg/?share_source=copy_web

---

## Day32 - Java

### synchronized和lock的区别是什么

**掌握程度：**
- 清晰地解释 synchronized 和 Lock 的区别
- 讨论它们各自的使用场景和优缺点

1. **来源：**
   - synchronized 是Java的关键字，是Java内置的同步机制
   - Lock 是Java java.util.concurrent.locks包下的一个接口，ReentrantLock 是其具体实现类

2. **使用方式：**
   - synchronized 可以通过修饰方法或代码块来使用，使用起来较为简单直观
   - Lock 需要显式创建锁对象，然后通过调用锁对象的方法（如 lock() 和 unlock()）来手动管理锁的获取和释放

3. **可中断性：**
   - synchronized 不能响应中断，一个线程在等待获取锁时，不能响应中断信号
   - Lock 可以响应中断，线程在获取锁的过程中可以响应中断信号并提前结束等待

4. **尝试非阻塞获取：**
   - synchronized 没有提供尝试获取锁的机制，一旦锁被占用，新来的线程只能等待
   - Lock 提供了 tryLock() 方法，允许线程尝试获取锁，如果获取失败可以选择其他操作而不是等待

5. **超时获取：**
   - synchronized 不支持超时获取锁
   - Lock 支持超时获取锁，可以通过 tryLock(long time, TimeUnit unit) 方法设置一个超时时间

6. **公平性：**
   - synchronized 不支持公平性设置，锁的获取顺序不保证是公平的
   - ReentrantLock 可以设置公平性（true 或 false），公平性锁按照线程请求的顺序来分配锁

7. **锁绑定多个条件：**
   - synchronized 只能锁定一个条件，如果要等待多个条件需要使用 Object 的 wait() 和 notify() 方法
   - ReentrantLock 可以与 Condition 对象配合使用，允许绑定多个条件，提供更灵活的条件等待和通知机制

8. **实现原理：**
   - synchronized 是基于进入和退出Monitor对象来实现的，与JVM的实现紧密相关
   - Lock 是基于AQS（AbstractQueuedSynchronizer）框架实现的，提供了更复杂的同步功能

**参考资料：**
- 【Java面试】面试被问lock和synchronized的区别，如何回答轻松搞定面试官！】

---

### synchronized和ReentrantLock的区别是什么

1. **实现方式：**
   - synchronized 是Java的关键字，可以用于修饰方法或代码块，实现同步
   - ReentrantLock 是Java java.util.concurrent.locks包中的一个类，需要显式创建和使用

2. **锁的实现：**
   - synchronized 是一种不可中断的锁，线程尝试获取锁失败后，会一直等待
   - ReentrantLock 可以响应中断，线程尝试获取锁失败后可以选择中断等待

3. **尝试获取锁：**
   - synchronized 没有提供尝试获取锁的机制
   - ReentrantLock 提供了 tryLock() 方法，可以立即返回是否获取成功

4. **超时获取锁：**
   - synchronized 不支持超时获取锁
   - ReentrantLock 支持超时获取锁，可以通过 tryLock(long timeout, TimeUnit unit) 方法实现

5. **公平性：**
   - synchronized 不支持公平性设置，锁的获取顺序不保证
   - ReentrantLock 可以设置公平性，通过构造函数参数 true 或 false 来选择

6. **条件变量：**
   - synchronized 可以使用 Object 的 wait()、notify() 和 notifyAll() 方法实现条件变量
   - ReentrantLock 可以与 Condition 对象配合使用，提供更灵活的条件变量支持

7. **锁状态检查：**
   - synchronized 没有提供检查锁状态的方法
   - ReentrantLock 提供了 isLocked()、isFair()、hasQueuedThreads() 等方法来检查锁的状态

8. **可重入性：**
   - synchronized 和 ReentrantLock 都支持可重入，即同一个线程可以多次获取同一把锁

**在面试中，你应该能够：**
- 清晰地解释 synchronized 和 ReentrantLock 的区别
- 讨论它们各自的使用场景和优缺点
- 讨论在并发编程中如何选择使用 synchronized 或 ReentrantLock
- 能够讨论高级特性，如条件变量的使用，以及如何实现更复杂的同步需求

**参考资料：**
- 【多线程与高并发 | ReentrantLock和synchronized的区别？】

---

## Day33 - Java

### volatile 关键字的作用有那些？

**掌握程度：**
- 解释volatile关键字如何确保变量的可见性
- 讨论volatile在内存屏障和指令重排序方面的作用
- 举例说明volatile关键字的使用场景，例如状态标志或单例模式中的双重检查锁定
- 比较volatile与锁（如synchronized）的优缺点和使用场景
- 讨论volatile不能替代锁的情况，如复合操作的原子性问题

**参考资料：**
- 【Java面试】被面试官问：volatile关键字有什么用？它的实现原理是什么？看看高手是如何回答的】

---

### volatile 与synchronized 的对比

1. **可见性：**
   - volatile 变量能够保证修改的可见性，即一个线程对volatile变量的写入对其他线程立即可见
   - synchronized 则不仅可以保证可见性，还可以保证原子性，确保一个线程在执行同步代码块时，其他线程不能进入

2. **原子性：**
   - volatile 关键字不能保证复合操作的原子性。例如，自增操作i++（即i = i + 1）不是一个原子操作，即使i是volatile变量，也可能导致线程安全问题
   - synchronized 可以保证在一个线程执行同步代码块时，其他线程不能进入，因此可以保证复合操作的原子性

3. **使用场景：**
   - volatile 适用于简单的读/写共享变量，且不会与其他操作组合的情况
   - synchronized 适用于需要原子性的操作，如多个步骤组成的复合操作，或者需要确保线程互斥的场景

4. **性能开销：**
   - volatile 变量访问的开销相对较小，因为它不会引起线程阻塞或唤醒的操作
   - synchronized 可能会引起更大的性能开销，因为它涉及线程的阻塞和唤醒，以及可能的上下文切换

5. **锁的粒度：**
   - volatile 不涉及锁的概念，它只是一个变量级的修饰符
   - synchronized 可以用于方法或代码块，提供了更细粒度的锁控制

6. **内存屏障：**
   - volatile 读写操作在Java内存模型中带有内存屏障（Memory Barrier）效果，确保指令重排序时不会把volatile变量的读写操作移到屏障之前或之后
   - synchronized 通过进入和退出同步块来实现内存屏障效果

7. **与final变量的区别：**
   - volatile 变量可以被重新赋值，而final变量一旦被初始化后，其值不能被改变

**在面试中，你应该能够：**
- 清晰地解释volatile和synchronized的区别
- 讨论它们各自的使用场景和优缺点
- 举例说明在实际编程中如何选择使用volatile或synchronized
- 讨论在并发编程中如何使用这些关键字来避免常见的问题，如竞态条件、死锁等

**参考资料：**
- 【请说说volatile和synchronized的区别？】

---

### JDK8有哪些新特性

**掌握程度：**

1. **Lambda 表达式**
2. **接口的默认方法和静态方法**
3. **Stream API**
4. **注解和类型推断的改进：** Java 8 允许注解在多个地方重复使用，并且扩展了注解的支持，允许在更广泛的上下文中使用注解
5. **新的 Date-Time API**
6. **Optional 类**
7. **Base64 API：** Java 8 引入了对 Base64 编码和解码的原生支持
8. **并行数组**

**参考资料：**
- 【超解析！最新八股"JDK1.8的新特性有哪些？"】

---

## Day33 - C++

### vector和list的区别

1. **存储方式：**
   - std::vector 通常以数组的形式连续存储元素，支持随机访问
   - std::list 以双向链表的形式存储元素，不支持随机访问

2. **性能特点：**
   - std::vector 提供快速的随机访问能力，但插入和删除操作可能较慢，特别是在容器的开始或中间位置
   - std::list 提供快速的插入和删除操作，但在访问元素时需要顺序遍历，不支持快速随机访问

3. **内存使用：**
   - std::vector 由于连续存储，通常有较小的内存开销
   - std::list 每个元素都需要额外的内存来存储指向前后元素的指针，因此内存开销较大

4. **容量和扩容：**
   - std::vector 可能会随着元素的添加而增长其容量，这涉及到复制或移动现有元素到新的内存位置
   - std::list 不需要考虑容量问题，元素的添加不会触发内存重新分配

5. **迭代器类型：**
   - std::vector 的迭代器可以是随机访问迭代器，支持高效的随机访问
   - std::list 的迭代器是双向迭代器，只能顺序访问元素

6. **使用场景：**
   - std::vector 适用于需要频繁随机访问元素的场景，如索引访问
   - std::list 适用于插入和删除操作频繁的场景，特别是当操作位置不固定时

7. **尾部追加性能：**
   - std::vector 在尾部追加元素通常非常快速，但如果超出当前容量，可能需要进行扩容操作
   - std::list 在任何位置追加元素的速度都很快，不涉及扩容问题

**在面试中，你应该能够：**
- 清晰地解释 std::vector 和 std::list 的区别
- 讨论它们各自的性能特点和适用场景
- 讨论迭代器的不同类型以及它们如何影响容器的使用

**参考资料：**
- 【4-华为面试题目vector和list区别（扩容、迭代器失效，怎么避免迭代器失效，线程安全性）】

---

### vector 底层原理和扩容过程

**掌握程度：**

1. **底层原理：**
   - std::vector 通常使用连续的内存空间存储元素，这意味着它在内存中是紧密排列的，类似于传统的C语言数组
   - 为了有效管理动态数组，std::vector 内部维护了三个主要的指针或迭代器：begin（指向起始元素）、end（指向最后一个元素的下一个位置）、capacity_end（指向分配的内存末尾）

2. **初始化和内存分配：**
   - 当创建一个 std::vector 时，它开始时不包含任何元素。如果提供了初始大小，std::vector 会分配足够的内存来存储这些元素
   - 如果没有提供初始大小，std::vector 可能只分配一个很小的初始内存块，或者根本不分配内存

3. **扩容机制：**
   - 当添加元素到 std::vector 使其超出当前容量时，需要进行扩容操作。这通常涉及到以下几个步骤：
     - 分配一块新的更大的内存区域
     - 将现有元素从旧内存区域复制或移动到新内存区域
     - 释放旧内存区域
     - 更新 end 和 capacity_end 指针

4. **容量和预留空间：**
   - std::vector 提供 reserve() 方法，允许预先指定一个期望的容量，这可以减少多次扩容的需要
   - capacity() 方法返回当前分配的内存大小，而 size() 返回当前存储的元素数量

5. **性能考虑：**
   - 扩容操作是 std::vector 的性能瓶颈，因为它涉及到元素的复制或移动以及内存分配

6. **扩容策略：**
   - 通常，新分配的容量是当前容量的两倍，这是一种常见的策略，旨在平衡扩容频率和内存使用

7. **元素访问：**
   - 由于 std::vector 的连续内存特性，它支持快速的随机访问

**在面试中，你应该能够：**
- 解释 std::vector 的底层实现原理，包括它如何使用连续内存存储元素
- 讨论 std::vector 的扩容机制，包括何时以及如何进行扩容

**参考资料：**
- 【C++面试题】vector底层实现原理】
- 【C++容器： vector是如何扩容的】

---

## Day34 - Java

### synchronized和lock的区别是什么

**掌握程度：**
- 清晰地解释 synchronized 和 Lock 的区别
- 讨论它们各自的使用场景和优缺点

1. **来源：**
   - synchronized 是Java的关键字，是Java内置的同步机制
   - Lock 是Java java.util.concurrent.locks包下的一个接口，ReentrantLock 是其具体实现类

2. **使用方式：**
   - synchronized 可以通过修饰方法或代码块来使用，使用起来较为简单直观
   - Lock 需要显式创建锁对象，然后通过调用锁对象的方法（如 lock() 和 unlock()）来手动管理锁的获取和释放

3. **可中断性：**
   - synchronized 不能响应中断，一个线程在等待获取锁时，不能响应中断信号
   - Lock 可以响应中断，线程在获取锁的过程中可以响应中断信号并提前结束等待

4. **尝试非阻塞获取：**
   - synchronized 没有提供尝试获取锁的机制，一旦锁被占用，新来的线程只能等待
   - Lock 提供了 tryLock() 方法，允许线程尝试获取锁，如果获取失败可以选择其他操作而不是等待

5. **超时获取：**
   - synchronized 不支持超时获取锁
   - Lock 支持超时获取锁，可以通过 tryLock(long time, TimeUnit unit) 方法设置一个超时时间

6. **公平性：**
   - synchronized 不支持公平性设置，锁的获取顺序不保证是公平的
   - ReentrantLock 可以设置公平性（true 或 false），公平性锁按照线程请求的顺序来分配锁

7. **锁绑定多个条件：**
   - synchronized 只能锁定一个条件，如果要等待多个条件需要使用 Object 的 wait() 和 notify() 方法
   - ReentrantLock 可以与 Condition 对象配合使用，允许绑定多个条件，提供更灵活的条件等待和通知机制

8. **实现原理：**
   - synchronized 是基于进入和退出Monitor对象来实现的，与JVM的实现紧密相关
   - Lock 是基于AQS（AbstractQueuedSynchronizer）框架实现的，提供了更复杂的同步功能

**参考资料：**
- 【Java面试】面试被问lock和synchronized的区别，如何回答轻松搞定面试官！】

---

### synchronized和ReentrantLock的区别是什么

1. **实现方式：**
   - synchronized 是Java的关键字，可以用于修饰方法或代码块，实现同步
   - ReentrantLock 是Java java.util.concurrent.locks包中的一个类，需要显式创建和使用

2. **锁的实现：**
   - synchronized 是一种不可中断的锁，线程尝试获取锁失败后，会一直等待
   - ReentrantLock 可以响应中断，线程尝试获取锁失败后可以选择中断等待

3. **尝试获取锁：**
   - synchronized 没有提供尝试获取锁的机制
   - ReentrantLock 提供了 tryLock() 方法，可以立即返回是否获取成功

4. **超时获取锁：**
   - synchronized 不支持超时获取锁
   - ReentrantLock 支持超时获取锁，可以通过 tryLock(long timeout, TimeUnit unit) 方法实现

5. **公平性：**
   - synchronized 不支持公平性设置，锁的获取顺序不保证
   - ReentrantLock 可以设置公平性，通过构造函数参数 true 或 false 来选择

6. **条件变量：**
   - synchronized 可以使用 Object 的 wait()、notify() 和 notifyAll() 方法实现条件变量
   - ReentrantLock 可以与 Condition 对象配合使用，提供更灵活的条件变量支持

7. **锁状态检查：**
   - synchronized 没有提供检查锁状态的方法
   - ReentrantLock 提供了 isLocked()、isFair()、hasQueuedThreads() 等方法来检查锁的状态

8. **可重入性：**
   - synchronized 和 ReentrantLock 都支持可重入，即同一个线程可以多次获取同一把锁

**在面试中，你应该能够：**
- 清晰地解释 synchronized 和 ReentrantLock 的区别
- 讨论它们各自的使用场景和优缺点
- 讨论在并发编程中如何选择使用 synchronized 或 ReentrantLock
- 能够讨论高级特性，如条件变量的使用，以及如何实现更复杂的同步需求

**参考资料：**
- 【多线程与高并发 | ReentrantLock和synchronized的区别？】

---

## Day36 - C++

### push_back()和emplace_back()的区别

**掌握程度：**

1. **push_back():**
   - push_back() 用于在容器的末尾添加一个元素的拷贝或移动对象
   - 当使用 push_back() 时，如果容器需要扩容，它将触发扩容机制，可能涉及到元素的复制或移动

2. **emplace_back():**
   - emplace_back() 用于在容器末尾就地构造一个元素，它避免了元素构造后再拷贝或移动的需要
   - emplace_back() 直接使用传入的参数来构造容器中的元素，提高了效率，特别是对于大型对象或需要多个参数构造的对象

3. **性能:**
   - emplace_back() 通常比 push_back() 更高效，因为它避免了不必要的拷贝或移动操作

4. **使用场景:**
   - 当你已经有一个现成的对象，并且想将它添加到容器中时，使用 push_back()
   - 当你需要使用构造参数直接在容器中构造一个新元素时，使用 emplace_back()

5. **返回值:**
   - push_back() 返回一个指向新添加元素的引用
   - emplace_back() 也返回一个引用，但它是指向新构造元素的引用

**在面试中，你应该能够：**
- 清晰地解释 push_back() 和 emplace_back() 的区别
- 讨论它们的性能差异以及为什么 emplace_back() 可能更优
- 讨论就地构造（in-place construction）的概念以及它如何帮助减少不必要的拷贝或移动

**参考资料：**
- 【emplace_back更好？能完美替代push_back吗？】

---

### map dequeu list的实现原理

**掌握程度：**

1. **std::map:**
   - std::map是基于红黑树实现的，它保证元素按照键的顺序进行排序
   - 每个节点存储了键值对（key-value pair），并根据键的比较结果进行自平衡
   - 红黑树是一种自平衡二叉搜索树，它通过颜色和节点的特定排列保持平衡

2. **std::deque (double-ended queue):**
   - std::deque是一个双端队列，允许在容器的两端进行快速的插入和删除操作
   - 它通常是基于一个节点数组实现的，每个节点存储一部分元素，并可以动态地增加或删除节点

3. **std::list:**
   - std::list是一个双向链表，提供了在任意位置快速插入和删除元素的能力
   - 每个节点包含数据和两个指针，分别指向前一个节点和后一个节点

**在面试中，你应该能够：**
- 解释std::map、std::deque和std::list的基本实现原理
- 讨论它们的性能特点，如在哪些操作下表现好或不好，例如std::map的查找性能通常比std::list好，但插入和删除可能较慢
- 讨论这些容器的迭代器特性，如std::map的迭代器如何遍历有序的键值对，std::deque和std::list的迭代器如何顺序访问元素

---

## Day36 - Java

### 为什么要有线程池？

**掌握程度：**
- 解释为什么需要线程池，包括它在资源管理和性能提升方面的作用
- 讨论线程池如何控制并发级别和提高响应速度
- 举例常见的线程池
- 讨论线程池的实现原理，包括任务队列和工作线程的同步机制

**参考资料：**
- 【高频面试题：你工作中什么场景使用什么线程池，为什么】
- 【腾讯一面：java有几种线程池？常见的线程池有哪几种？分别说一下。。】

---

### 说一说线程池有哪些常用参数

**掌握程度：**

1. **核心线程数（Core Pool Size）:**
   - 线程池中常驻的线程数量，即使它们处于空闲状态，也不会被回收

2. **最大线程数（Maximum Pool Size）:**
   - 线程池中允许的最大线程数量。如果任务太多，超出核心线程数的线程会在处理完任务后被回收

3. **工作队列（Work Queue）:**
   - 用于存储等待执行的任务的队列。如果核心线程都忙碌，新任务将被放入此队列

4. **线程存活时间（Keep-Alive Time）:**
   - 当线程池中线程数量超过核心线程数时，非核心线程空闲时的存活时间

5. **线程工厂（Thread Factory）:**
   - 用于创建新线程的工厂，可以自定义线程的名称、优先级等属性

6. **拒绝策略（Rejected Execution Handler）:**
   - 当任务太多，无法被工作队列或线程池及时处理时，定义了任务被拒绝的处理策略

7. **任务接口（Task Interface）:**
   - 线程池执行的任务需要实现的接口，如 Runnable 或 Callable

8. **线程优先级（Thread Priority）:**
   - 线程池中线程的优先级，影响线程的调度顺序

9. **定时任务与周期任务:**
   - 线程池支持定时执行或周期性执行的任务

10. **允许核心线程时间（Allow Core Thread Timeout）:**
    - 是否允许核心线程超时并被终止

**在面试中，你应该能够：**
- 解释这些参数的含义及其对线程池行为的影响
- 讨论如何根据应用需求合理配置这些参数
- 讨论线程池参数配置不当可能导致的问题，如资源浪费、系统过载或响应延迟

**参考资料：**
- 【请解释一下线程池7个参数的含义？】

---

### BIO、NIO、AIO 的区别

**掌握程度：**
- 清晰地解释BIO、NIO和AIO三种I/O模型的区别
- 讨论它们的使用场景和优缺点，例如BIO适合低并发场景，NIO和AIO适合高并发场景
- 讨论I/O多路复用、事件驱动等概念，以及它们如何影响I/O模型的设计和实现

**参考资料：**
- 【中级面试题：BIO、NIO、AIO之间的区别以及各自的应用场景？】

---

## Day37 - C++

### map 和 unordered_map的区别和实现机制

**掌握程度：**

1. **底层实现:**
   - std::map基于红黑树实现，保证元素按照键的顺序进行排序
   - std::unordered_map基于哈希表实现，不保证元素顺序，通过哈希函数将键映射到哈希表的槽位

2. **性能特点:**
   - std::map提供对数时间复杂度的查找、插入和删除操作
   - std::unordered_map在理想情况下提供常数时间复杂度的查找、插入和删除操作，但最坏情况下可能退化为线性时间复杂度

3. **元素排序:**
   - std::map中的元素自动根据键排序
   - std::unordered_map中的元素没有顺序，如果需要排序，需要额外操作

4. **内存使用:**
   - std::map可能使用更多的内存，因为它需要存储额外的树节点信息
   - std::unordered_map通常使用较少的内存，因为它只需要存储键值对和哈希表

5. **使用场景:**
   - 当需要有序遍历键值对或者进行范围查询时，使用std::map
   - 当性能是关键考虑，且不关心元素顺序时，使用std::unordered_map

6. **冲突解决:**
   - std::map通过红黑树的自平衡特性解决元素冲突
   - std::unordered_map通过哈希函数和冲突解决策略（如链表法或开放寻址法）解决冲突

**在面试中，你应该能够：**
- 解释std::map和std::unordered_map的底层实现和它们如何影响性能
- 讨论它们的使用场景和优缺点
- 讨论红黑树和哈希表的特性，以及它们如何适用于不同的数据结构

**参考资料：**
- 【C++面试题】map和unordered_map相关面试题】

---

### C++11新特性有哪些

**掌握程度：**

1. **自动类型推断（auto）:**
   - 允许编译器自动推断变量的类型，简化模板编程和迭代器的使用

2. **基于范围的for循环（Range-based for loop）:**
   - 提供了一种新的for循环语法，使遍历容器和数组更加简洁

3. **lambda表达式（Lambda expressions）:**
   - 允许在代码中直接创建匿名函数，简化了函数对象的使用

4. **智能指针（Smart pointers）:**
   - 如std::unique_ptr、std::shared_ptr和std::weak_ptr，提供了自动内存管理

5. **右值引用和移动语义（Right-value references and move semantics）:**
   - 允许更高效的资源转移，减少不必要的拷贝，提高性能

6. **标准库线程支持（Thread support in the standard library）:**
   - 引入了线程库，提供了多线程编程的基本工具

7. **改进的容器和算法（Improved containers and algorithms）:**
   - 标准库中添加了新的容器和算法，如std::array、std::unordered_map等

**参考资料：**
- 【你应该立即掌握的10个现代C++新特性】
- 【C++面试100问】第四问：C++常用新特性有哪些，请举例说明？】

---

## Day37 - Java

### java 内存区域有哪些部分

**掌握程度：**
- 列举Java内存区域的各个部分，并简要解释每个部分的作用
- 讨论Java内存模型以及它对多线程编程的影响
- 举例说明程序计数器、Java虚拟机栈、本地方法栈在线程执行过程中的作用
- 讨论Java堆和方法区在对象创建和类信息存储中的作用
- 说明垃圾回收机制，以及它在Java堆中如何工作

**参考资料：**
- 【java】jvm内存模型全面解析】

---

### 介绍一下什么是强引用、软引用、弱引用、虚引用

**掌握程度：**
- 解释强引用、软引用、弱引用、虚引用的区别和用途
- 讨论不同引用类型对垃圾回收的影响
- 举例说明在实际编程中如何使用软引用和弱引用来实现缓存或者跟踪对象的生命周期
- 讨论使用这些引用类型可能遇到的问题，如内存泄漏、对象提前回收等

**参考资料：**
- 【Java面试】资深Java工程师必问面试题，强引用、软引用、弱引用、虚引用有什么区别？】

---

### 有哪些垃圾回收算法

1. **引用计数法（Reference Counting）:**
   - 每个对象有一个引用计数，当引用被创建或删除时，计数相应增加或减少。当计数为零时，对象可被回收
   - 优点是对象回收及时，但缺点是无法处理循环引用

2. **标记-清除（Mark-Sweep）:**
   - 分为两个阶段：首先标记所有可达对象，然后清除所有未标记的对象
   - 缺点是会产生内存碎片

3. **复制算法（Copying）:**
   - 将内存分为两个区域，交替使用。每次回收时，将存活的对象复制到另一个区域，并清空当前区域
   - 优点是可以连续内存分配，避免了内存碎片，但缺点是效率较低，且只能利用一半的内存

4. **标记-整理（Mark-Compact）:**
   - 在标记-清除的基础上增加了整理过程，将存活的对象移动到内存的一端，然后清理边界外的对象
   - 解决了内存碎片问题，但增加了GC的复杂度

5. **分代收集（Generational Collection）:**
   - 基于对象生命周期的不同，将对象分配到不同的代中，新创建的对象在新生代，存活时间久的对象在老年代
   - 新生代使用复制算法，老年代使用标记-清除或标记-整理算法

6. **增量收集（Incremental Collection）:**
   - 将垃圾回收过程分成多个小步骤，逐步进行，减少GC暂停时间

7. **并发收集（Concurrent Collection）:**
   - 垃圾回收与应用程序并发执行，减少GC暂停时间，提高系统响应性

8. **分区收集（Region-based Collection, RBC）:**
   - 将堆划分为多个小区域，可以并行处理这些区域，提高GC效率

**在面试中，你应该能够：**
- 列举并解释上述垃圾回收算法的基本概念和工作原理
- 讨论不同算法的优缺点，以及它们适用的场景
- 讨论现代垃圾回收器（如Java中的G1、ZGC、Shenandoah等）的设计理念和特点

**参考资料：**
- 【 Java面试满分回答——Java垃圾回收算法】

---

### 有哪些垃圾回收器

1. **Serial收集器:**
   - 单线程执行，适合内存资源受限的环境，如小型应用或者单核处理器

2. **ParNew收集器:**
   - Serial收集器的多线程版本，适合新生代的垃圾回收

3. **Parallel Scavenge收集器:**
   - 并行收集器，使用复制算法，注重吞吐量，适合科学计算和后台处理等场景

4. **Serial Old收集器:**
   - Serial收集器的老年代版本，使用标记-整理算法

5. **Parallel Old收集器:**
   - Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法

6. **CMS（Concurrent Mark Sweep）收集器:**
   - 以最小化停顿时间为目标，使用标记-清除算法，适合交互式应用

7. **G1（Garbage-First）收集器:**
   - 区域化堆布局，可预测停顿时间，适合大堆内存和需要快速响应的应用

8. **ZGC（Z Garbage Collector）:**
   - JDK 11中引入的实验性收集器，低延迟，支持TB级别堆内存，最大GC停顿时间目标为10ms

9. **Shenandoah:**
   - 低延迟收集器，与G1类似，但使用更细粒度的分区，减少GC引起的停顿

10. **Epsilon:**
    - 无操作（No-Op）收集器，不执行任何垃圾回收，主要用于性能测试

**在面试中，你应该能够：**
- 列举并解释上述垃圾回收器的名称和特点
- 讨论不同垃圾回收器的适用场景和优缺点

**参考资料：**
- 【5分钟背八股】118：JVM有哪些垃圾回收器，实际中如何选择？】

---

## Day38 - C++

### 移动语义有什么作用，原理是什么

**参考资料：**
- 【全网第一C++移动语义讲解！】

1. **移动语义的作用：**
   - 解释移动语义的主要目的是提高资源（如内存、文件句柄等）的利用效率
   - 说明移动语义允许对象的资源从一个对象转移到另一个对象，而不是复制

2. **移动语义与复制语义的区别：**
   - 复制语义涉及对象的深拷贝，而移动语义涉及资源的转移
   - 复制语义通常用于创建对象的副本，而移动语义用于对象的所有权转移

3. **移动构造函数和移动赋值运算符：**
   - 描述移动构造函数（Move Constructor）的作用，即接受一个即将被销毁的对象的资源
   - 描述移动赋值运算符（Move Assignment Operator）的作用，即将资源从一个对象转移到另一个对象

4. **右值引用：**
   - 解释右值引用（Right Value Reference）的概念，它是移动语义的关键组成部分
   - 说明右值引用如何与移动构造函数和移动赋值运算符一起工作

5. **标准库中的移动语义：**
   - 举例说明标准库容器（如std::vector、std::string等）如何实现移动语义

6. **移动语义的实现原理：**
   - 描述如何通过重载构造函数和赋值运算符来实现移动语义
   - 解释std::move函数的作用和使用场景

---

### 左值引用和右值引用的区别

1. **基本概念：**
   - 解释左值引用是指向具有确定生命周期对象的引用
   - 解释右值引用是指向即将销毁或临时对象的引用

2. **左值和右值：**
   - 左值表达式：在求值后，可以取得一个地址的表达式，可以出现在赋值表达式的左边或右边
   - 右值表达式：在求值后，不能取得地址的表达式，通常出现在赋值表达式的右边

3. **引用的使用：**
   - 左值引用必须绑定到左值上，用于访问对象的身份
   - 右值引用可以绑定到右值上，主要用于移动语义，实现资源的转移

4. **语法表示：**
   - 左值引用在类型后面使用一个&符号，如int&
   - 右值引用在类型后面使用两个&符号，如int&&

5. **移动语义：**
   - 说明右值引用在C++11移动语义中的使用，允许资源从即将销毁的对象转移到另一个对象

6. **std::move：**
   - 解释std::move的作用，它将左值转换为右值引用，使得可以利用移动构造函数或移动赋值运算符

**参考资料：**
- 【6.2~3 左值引用和右值引用】

---

## Day38 - Java

### 类加载机制介绍一下

1. **类加载的三个阶段：** 简要描述Java类加载机制的三个主要阶段：加载（Loading）、链接（Linking）、初始化（Initialization）

2. **加载阶段：** 解释类加载器如何接收类名并通过类的全限定名来查找这个类的二进制数据流

3. **链接阶段：** 细分为验证（Verification）、准备（Preparation）和解析（Resolution）三个子阶段：
   - **验证：** 确保加载的类信息符合虚拟机规范，没有安全问题
   - **准备：** 为类的静态变量分配内存，并设置默认初始值
   - **解析：** 将类、接口、字段和方法的符号引用转换为直接引用

4. **初始化阶段：** 说明何时触发类的初始化，即当类或接口的静态变量、静态方法或使用static关键字修饰的代码块被引用时

5. **类加载器：** 描述Java中的类加载器层次结构，包括启动类加载器（Bootstrap ClassLoader）、扩展类加载器（Extension ClassLoader）和应用程序类加载器（Application ClassLoader）

6. **双亲委派模型：** 解释类加载器的双亲委派模型，即一个类加载器在尝试加载类之前，会先委托给它的父类加载器去尝试加载这个类

7. **自定义类加载器：** 提及Java允许开发者实现自己的类加载器，以满足特殊的类加载需求

8. **类的唯一性：** 说明同一个类加载器加载的同一个名称的类是相同的，不同的类加载器加载的同一个名称的类是不同的

**在面试中，至少应该能够：**
- 清晰地概述Java类加载机制的三个阶段和每个阶段的主要任务
- 解释类加载器的作用和双亲委派模型的重要性

**参考资料：**
- 【【JVM】Java类加载机制这块算是玩明白了】

---

### 双亲委派机制介绍一下

1. **基本概念：** 双亲委派机制是指在加载一个类时，类加载器首先会请求其父加载器去尝试加载这个类，只有当父加载器无法完成这个请求时，子加载器才会尝试自己去加载

2. **层次结构：** 描述Java类加载器的层次结构，包括：
   - 启动类加载器（Bootstrap ClassLoader），负责加载Java核心库
   - 扩展类加载器（Extension ClassLoader），负责加载扩展目录下的类库
   - 应用程序类加载器（Application ClassLoader），负责加载应用程序的类路径（classpath）上的类

3. **工作流程：** 说明当一个类需要被加载时，类加载请求首先被发送到启动类加载器，如果它不能完成加载，请求会被委派给扩展类加载器，依此类推，直到应用程序类加载器

4. **优点：**
   - 避免核心库的重复加载，确保Java核心库的唯一性
   - 保证Java核心库的类型安全，防止恶意代码篡改核心库

5. **自定义类加载器：** 提及开发者可以通过继承ClassLoader类来实现自定义类加载器，但自定义类加载器在加载类时也应该遵循双亲委派模型

6. **委派模型的例外：** 说明在某些情况下，类加载器可以选择不遵循双亲委派模型，例如，自定义类加载器可以覆盖loadClass方法来实现自己的加载逻辑

7. **实际应用：** 讨论双亲委派机制在实际开发中的应用，例如，如何通过类加载器来实现模块化、热部署等

**在面试中，至少应该能够：**
- 清晰地解释双亲委派机制的工作原理和层次结构
- 讨论双亲委派机制的优点

**参考资料：**
- 【【Java面试】请介绍类加载过程，什么是双亲委派？】

---

### 说一说你对Spring AOP的了解

1. **AOP的概念：** 解释什么是面向切面编程，以及它与传统的面向对象编程的区别

2. **AOP的关键术语：**
   - **切面（Aspect）：** 包含横切关注点的模块
   - **连接点（Join point）：** 程序执行过程中可以插入切面的点，如方法的调用或异常的抛出
   - **切点（Pointcut）：** 匹配连接点的表达式，用于定义哪些连接点将被切面所切入
   - **通知（Advice）：** 实际的切面代码，定义了在切点处要执行的动作，如前置、后置、环绕和异常通知
   - **目标对象（Target Object）：** 被通知的对象
   - **代理（Proxy）：** 包含目标对象和切面逻辑的对象

3. **Spring AOP的实现机制：** 描述Spring AOP是如何通过代理机制实现的，包括JDK动态代理和CGLIB代理

4. **AOP的类型：**
   - **编译时AOP：** 在编译期间织入切面，如AspectJ
   - **运行时AOP：** 在运行时通过代理织入切面，如Spring AOP

5. **Spring AOP的配置方式：**
   - **XML配置：** 通过XML文件定义切面、切点和通知
   - **注解配置：** 使用@AspectJ注解定义切面和相关组件

6. **使用Spring AOP的场景：** 举例说明在哪些场景下使用Spring AOP，如事务管理、日志记录、性能监控等

7. **Spring AOP与AspectJ的关系：** 解释Spring AOP与AspectJ的关系，以及它们在实现AOP时的异同

8. **Spring AOP的局限性：** 讨论Spring AOP在某些情况下可能遇到的局限性，如不能处理方法的重载问题

**参考资料：**
- 【Spring面试必问：说说你对AOP的理解】

---

### 说一说你对 Spring中IOC的理解

1. **IoC的基本概念：** IoC是一种设计原则，它将对象的创建和它们之间的依赖关系交由外部容器来管理，而不是由程序代码直接控制

2. **依赖注入（Dependency Injection，DI）：** 解释依赖注入是IoC的一个主要实现方式，它允许对象通过构造函数、setter方法或接口注入它们需要的其他对象

3. **Spring IoC容器：** 描述Spring IoC容器的作用，它是一个用来实现IoC的框架组件，负责管理bean的生命周期和依赖关系

4. **bean的概念：** 说明在Spring中，bean是构成应用程序主体的组件，它们由Spring IoC容器进行管理

5. **配置方式：** 概述Spring IoC容器配置bean的几种方式，包括XML配置、注解（如@Component, @Service, @Repository, @Autowired等）和Java配置类

6. **作用域：** 讨论Spring中bean的几种作用域，如singleton（单例）、prototype（原型）、request、session等

7. **生命周期管理：** 解释Spring IoC容器如何管理bean的生命周期，包括初始化、使用和销毁

8. **自动装配：** 提及Spring的自动装配功能，它允许容器尝试自动满足bean的依赖关系

9. **IoC的优点：** 讨论IoC带来的优势，如降低代码间的耦合度、提高模块化、易于测试和维护

**在面试中，至少应该能够：**
- 清晰地解释IoC和DI的概念及其在Spring中的应用
- 描述Spring IoC容器的工作原理和它如何管理bean

**参考资料：**
- 【好好和大家聊聊什么是spring的IOC。】

---

## Day39 - C++

### 什么是菱形继承

1. **菱形继承的定义：**
   - 解释菱形继承是指当两个子类继承同一个基类，然后有一个类同时继承这两个子类时，形成的继承结构

2. **菱形继承的问题：**
   - 讨论菱形继承可能导致的问题，主要是基类部分的多重继承导致的数据成员和方法的二义性

3. **虚继承：**
   - 描述虚继承的概念，以及它是如何解决菱形继承问题的。通过使用虚继承，可以确保基类只被继承一次

4. **多重继承的优缺点：**
   - 讨论多重继承的优点，如代码复用和灵活性；以及缺点，如复杂性和潜在的二义性问题

5. **设计原则：**
   - 讨论如何解决菱形继承带来的问题，包括遵循一些设计原则，如里氏替换原则和依赖倒置原则

6. **编程语言的比较：**
   - 如果适用，可以简要比较不同编程语言对菱形继承问题的处理方式，如Java不支持多重继承

---

### C++中的多线程同步机制

1. **解释线程同步的概念：** 线程同步是指在多线程环境中，为了防止多个线程同时访问共享资源导致数据不一致或其他未预期的行为，而采取的一系列措施。这包括使用锁、信号量、条件变量等机制来协调和控制线程的执行顺序和时间

2. **描述多线程同步的重要性：** 多线程编程中，当两个或多个线程需要访问共享资源时，如全局变量、数据结构等，必须实施同步机制以确保数据的一致性和程序的正确性。没有同步，可能会出现数据竞争、死锁等问题

3. **说明常见的同步问题：** 包括竞争条件（多个线程同时访问同一资源导致结果不确定）和死锁（两个或多个线程互相等待对方释放资源，导致系统无法继续执行）

4. **讨论解决同步问题的方法：**
   - 使用互斥锁（Mutex）：通过加锁和解锁操作来保护共享资源，确保一次只有一个线程可以访问该资源
   - 使用条件变量：允许线程等待某个条件成立后再继续执行，用于解决线程间的协调问题
   - 避免死锁：通过合理的加锁顺序、使用RAII技术、减少不必要的锁等策略来减少死锁的发生

---

### 如何在C++中创建和管理线程？

1. **解C++11线程库：**
   - 理解C++11标准引入的线程支持，包括 <thread>, <mutex>, <atomic>, <condition_variable> 等头文件

2. **创建线程：**
   - 能够描述如何使用 std::thread 类来创建线程，并传递函数或函数对象给线程执行

3. **线程的启动和分离：**
   - 知道如何通过调用 std::thread 对象的 join() 方法来等待线程结束，以及如何使用 detach() 方法让线程在后台运行

4. **线程的同步：**
   - 理解互斥锁（std::mutex）和锁_guard（std::lock_guard）的使用，以及如何防止死锁

5. **线程安全的数据共享：**
   - 描述原子操作（std::atomic）和条件变量（std::condition_variable）的基本概念和使用

6. **线程局部存储：**
   - 知道 thread_local 关键字用于定义线程特定的局部变量

7. **线程池的概念：**
   - 如果适用，了解线程池的基本概念，以及它如何管理和优化线程资源

8. **线程的生命周期管理：**
   - 理解线程从创建到销毁的整个过程，包括异常安全和资源管理

---

## Day39 - Java

### 描述一下SpringMVC的执行流程

**掌握程度：**

1. **客户端请求：** 用户通过浏览器发送HTTP请求到服务器

2. **DispatcherServlet：** 请求首先到达Spring MVC的前端控制器DispatcherServlet。它是整个流程的中心，负责将请求路由到相应的处理器

3. **HandlerMapping：** DispatcherServlet使用一个或多个HandlerMapping来确定请求应该由哪个处理器（Controller）来处理。HandlerMapping会根据请求的URL找到对应的Controller和方法

4. **Controller：** 一旦找到合适的Controller，请求就会被转发到相应的方法处理。Controller负责业务逻辑的处理，并且返回一个模型（Model）和视图（View）

5. **ModelAndView：** Controller方法执行完成后，会返回一个ModelAndView对象，它包含了模型数据和视图名称

6. **ViewResolver：** DispatcherServlet使用ViewResolver来解析ModelAndView中的视图名称。ViewResolver负责将逻辑视图名称转换为具体的视图实现

7. **视图渲染：** 根据解析得到的视图实现，DispatcherServlet将模型数据渲染到视图中，生成最终的HTML页面

8. **返回响应：** 渲染完成后，DispatcherServlet将响应发送回客户端浏览器

9. **异常处理：** 如果在执行过程中出现异常，DispatcherServlet会使用HandlerExceptionResolver来处理异常

**参考资料：**
- 【【java面试题】说说SpringMVC的执行流程？】

---

### SpringBoot Starter有什么用

**你应该能够：**
- 解释Spring Boot Starter是什么，以及它们的基本作用
- 描述Starters如何简化依赖管理和自动配置
- 举例说明一些常见的Starters，如spring-boot-starter-web、spring-boot-starter-data-jpa等
- 讨论Starters如何帮助提高开发效率和保持项目配置的一致性

1. **依赖管理简化：** Starters是一组预定义的依赖项，它们通过pom.xml（对于Maven）或build.gradle（对于Gradle）中的一个单一依赖引入，自动帮你管理项目所需的所有依赖

2. **开箱即用：** Starters提供了一种快速启动和配置Spring Boot应用的方式，你不需要手动添加和管理大量的依赖，可以快速开始开发

3. **一致性配置：** Starters通常包含Spring Boot团队推荐的配置，这保证了不同项目之间的一致性和最佳实践

4. **自动配置：** Spring Boot的自动配置机制会根据你添加的Starters自动配置Spring应用。例如，如果你添加了spring-boot-starter-web，Spring Boot会自动配置Tomcat和Spring MVC

5. **定制化：** 尽管Starters提供了默认配置，你仍然可以覆盖它们，以满足特定的需求

6. **社区和插件生态：** Spring Boot有一个丰富的Starter生态，包括官方和社区提供的Starters，可以很容易地扩展应用的功能

---

### SpringBoot的常用注解

【一文掌握 Spring Boot 常用注解，保姆级整理，建议收藏！】

1. **@SpringBootApplication：** 组合注解，包括@EnableAutoConfiguration、@ComponentScan等，用于启动Spring Boot应用程序

2. **@RestController：** 组合注解，包括@Controller和@ResponseBody，通常用于定义RESTful web服务

3. **@RequestMapping：** 用于映射HTTP请求到控制器的处理方法上，可以用于类或方法

4. **@GetMapping, @PostMapping, @PutMapping, @DeleteMapping：** 分别是@RequestMapping的特定HTTP方法的便捷注解，用于简化方法级别的映射

5. **@Autowired：** 用于自动装配依赖注入，可以注解在字段、构造函数、设置方法或普通方法上

6. **@Service, @Repository, @Component：** 用于定义服务层、数据访问层和组件层的组件

7. **@Value：** 用于将配置属性注入到字段中

8. **@Configuration：** 标记配置类，可以包含@Bean注解的方法，用于定义配置信息

9. **@Bean：** 在配置类中使用，用于声明一个bean

10. **@Profile：** 用于指定类或方法在哪些环境下可用

11. **@PropertySource：** 用于加载属性文件

12. **@EnableAutoConfiguration：** 告诉Spring Boot根据添加的jar依赖自动配置项目

13. **@ResponseBody：** 用于方法级别，表示该方法的返回值直接作为响应体返回

14. **@RestControllerAdvice：** 用于全局异常处理或静态资源的配置

15. **@PathVariable：** 用于方法参数，用于提取URI模板中的变量

---

## Day40 - C++

### 什么是构造函数和析构函数？构造函数、析构函数可以是虚函数嘛

**参考资料：**
- 【构造函数与析构函数】
- 【C++多态中析构函数为什么要写成虚函数？（答案见简介）】

---

### 虚函数是怎么实现的

**掌握程度**

1. **理解虚函数的基本概念：** 能够解释虚函数是C++中用于实现多态性的一种特殊函数，使用virtual关键字声明，并可在派生类中被重写

2. **掌握虚函数的工作原理：** 能够描述虚函数的实现原理是基于虚函数表（VTable）和虚表指针（vptr），每个类拥有一个虚函数表，每个对象拥有一个指向该表的虚表指针

3. **理解虚函数表的构造过程：** 能够讨论编译器如何为包含虚函数的类创建虚函数表，以及派生类如何继承或重写基类的虚函数，从而形成自己的虚函数表

4. **区分动态绑定和静态绑定：** 够解释动态绑定（Dynamic Binding）是在程序运行时确定函数调用的过程，而静态绑定（Static Binding）是在编译时确定的

5. **讨论虚函数的使用场景和好处：** 能够说明虚函数允许通过基类指针或引用调用派生类的实现，从而实现多态性，并讨论其在设计模式和代码复用中的作用

**参考资料：**
- 【C++面试100问】第十一问：虚函数是什么？工作机制是什么？】

---

### 虚函数表是什么

**掌握程度：**

1. **理解虚函数表（VTable）的基本概念：** 能够解释虚函数表是存储类中虚函数地址的数组，是实现多态的关键机制之一

2. **掌握虚函数表的工作原理：** 能够描述当通过基类指针或引用调用虚函数时，是如何通过虚函数表来确定调用派生类中的函数实现的

3. **理解虚函数表和对象的关系：** 能够说明每个包含虚函数的类都有自己的虚函数表，且同一类的所有对象共享这张表

4. **理解虚表指针（vptr）的作用：** 能够解释对象内部包含的虚表指针指向类的虚函数表，这是如何帮助实现动态绑定的

5. **区分单继承和多重继承下的虚函数表：** 能够讨论在单继承和多重继承情况下，虚函数表的不同表现，以及如何处理多张虚函数表

6. **了解虚函数表的内存布局：** 能够讨论虚函数表在内存中的位置，以及如何通过对象的地址访问其虚函数表

---

## Day40 - Java

### Java 创建线程有哪几种方式？

**掌握程度：**

在Java中，创建线程主要有以下几种方式：

1. **继承Thread类：**
   - 通过创建一个新的类继承Thread类，重写run方法来定义线程执行的任务
   - 这种方式可以通过创建Thread的实例，并调用其start方法来启动线程

2. **实现Runnable接口：**
   - 创建一个类实现Runnable接口，并实现其run方法
   - 这种方式需要将Runnable实现类的实例传递给Thread对象，然后通过调用Thread对象的start方法来启动线程

3. **实现Callable接口：**
   - Callable接口与Runnable类似，但它可以返回值，并且可以抛出异常
   - 实现Callable接口的类必须实现call方法，然后可以将这个实现的实例传递给FutureTask，再将FutureTask传递给Thread来启动线程
   - Callable方式的线程可以通过Future获取任务执行的返回值

4. **使用Executor框架：**
   - Java 5 引入了基于固定数量的线程池的Executors类，可以创建不同类型的线程池来管理线程
   - 这种方式使用ExecutorService来管理线程的创建和执行，可以通过submit方法提交任务，并返回一个Future对象

5. **使用匿名内部类：**
   - 在某些情况下，可以使用匿名内部类来实现Runnable或Callable接口，特别是在只需要使用一次的简单线程任务中

6. **使用Lambda表达式（Java 8及以上）：**
   - 利用Java 8的Lambda表达式简化Runnable或Callable的实现，通常与Executor框架一起使用

**在面试中，你应该能够：**
- 解释上述每种方式的基本使用方法和适用场景
- 讨论各种方式的优缺点，例如Thread和Runnable的选择，以及Callable和Future的用途
- 说明Executor框架如何简化线程管理，并讨论线程池的基本概念
- 讨论线程的生命周期、状态以及如何在Java中管理线程

**参考资料：**
- 【腾讯一面：请问java如何创建线程？创建线程的方式有几种？】

---

### 线程start和run的区别

**掌握程度：**

1. **理解start()方法的作用：**
   - start()方法用于启动一个新线程。当调用这个方法时，如果线程尚未开始，它会允许线程对run()方法中的代码进行执行。start()方法会创建一个新的执行栈，并将run()方法的执行安排在新线程中

2. **理解run()方法的作用：**
   - run()方法是Thread类的一个重写点，以及Runnable和Callable接口的实现方法。它包含线程执行的代码。run()方法通常在新线程的上下文中被调用，但它本身并不启动线程

3. **知道为什么不应该直接调用run()：**
   - 直接调用run()方法不会创建新线程，而是在当前线程中同步执行run()中的代码。这意味着它不会利用多线程的优势，并且可能阻塞其他线程的执行

4. **理解两者的调用关系：**
   - 当start()被调用时，它会导致线程的执行，而这个线程最终会调用run()方法。start()和run()不应该直接相互调用

5. **讨论线程的生命周期：**
   - 能够讨论线程创建后的状态变化，如从新建状态到就绪状态，再到运行状态，以及它们如何与start()和run()方法相关

**参考资料：**
- 【Java高级】为什么启动线程不直接调用run()，而要调用start()，如果调用两次start()方法会有什么后果？】

---

## Day40 - 测开

### web自动化中元素定位方式有哪些？

1. **ID定位：** 通过元素的ID属性进行定位，这是最简单和最快的定位方法
2. **Name定位：** 通过元素的Name属性进行定位，适用于没有ID的元素
3. **Class Name定位：** 通过元素的Class属性进行定位，可以定位具有相同类名的所有元素
4. **Tag Name定位：** 通过元素的标签名进行定位，如<div>、<span>等
5. **XPath定位：** 使用XPath表达式进行复杂的元素定位，可以结合属性、文本内容、位置等信息
6. **CSS Selector定位：** 使用CSS选择器进行元素定位，支持类名、属性、伪类等多种选择方式
7. **Link Text定位：** 通过链接的完整文本内容进行定位
8. **Partial Link Text定位：** 通过链接文本的部分内容进行定位

---

### 你是如何处理iframe里面元素定位的?

### ui自动化中定位不到元素的原因有哪些

### 显式等待和隐式等待的区别

---

