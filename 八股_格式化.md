# Java方向

## 计算机网络

### TCP/IP网络模型/OSI模型

OSI模型，是国际标准化组织（ISO）制定的一个用于计算机或通信系统间互联的标准体系，将计算机网络通信划分为七个不同的层级，每个层级都负责特定的功能。每个层级都构建在其下方的层级之上，并为上方的层级提供服务。七层从下到上分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。虽然OSI模型在理论上更全面，但在实际网络通信中，TCP/IP模型更为实用。TCP/IP模型分为四个层级，每个层级负责特定的网络功能。

1. **应用层**：该层与OSI模型的应用层和表示层以及会话层类似，提供直接与用户应用程序交互的接口。它为网络上的各种应用程序提供服务，如电子邮件（SMTP）、网页浏览（HTTP）、文件传输（FTP）等。

2. **传输层**：该层对应OSI模型的传输层。它负责端到端的数据传输，提供可靠的、无连接的数据传输服务。主要的传输层协议有TCP和UDP。TCP提供可靠的数据传输，确保数据的正确性和完整性；而UDP则是无连接的，适用于不要求可靠性的传输，如实时音频和视频流。

3. **网际层**：该层对应OSI模型的网络层。主要协议是IP，它负责数据包的路由和转发，选择最佳路径将数据从源主机传输到目标主机。IP协议使用IP地址来标识主机和网络，并进行逻辑地址寻址。

4. **网络接口层**：该层对应OSI模型的数据链路层和物理层。它负责物理传输媒介的传输，例如以太网、Wi-Fi等，并提供错误检测和纠正的功能。此外，网络接口层还包含硬件地址（MAC地址）的管理。

### 从输入URL到页面展示发生了什么

1. 输入网址，解析URL信息，准备发送HTTP请求

2. 检查浏览器缓存里是否有缓存该资源，如果有直接返回；如果没有进入下一步网络请求。

3. DNS域名解析：网络请求前，进行DNS解析，以获取请求域名的IP地址。DNS解析时会按本地浏览器缓存->本地Host文件->路由器缓存->DNS服务器->根DNS服务器的顺序查询域名对应IP，直到找到为止。

4. TCP三次握手建立连接：浏览器与服务器IP建立TCP连接。

5. 客户端发送HTTP请求：连接建立后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的Cookie等数据附加到请求头中，向服务器构建请求信息。如果是HTTPS的话，还涉及到HTTPS的加解密流程。

6. 服务器处理请求并返回HTTP资源：服务器接收到请求信息，根据请求生成响应数据。

7. TCP四次挥手断开连接：浏览器与服务器IP断开TCP连接。

8. 浏览器解析响应并渲染页面：
   - 浏览器解析响应头。若响应头状态码为301、302，会重定向到新地址；若响应数据类型是字节流类型，一般会将请求提交给下载管理器；若是HTML类型，会进入下一部渲染流程。
   - 浏览器解析HTML文件，创建DOM树，解析CSS进行样式计算，然后将CSS和DOM合并，构建渲染树；最后布局和绘制渲染树，完成页面展示。

### HTTP请求报文和响应报文是怎样的，有哪些常见的字段？

HTTP报文分为请求报文和响应报文。

#### （1）请求报文

请求报文主要由请求行、请求头、空行、请求体构成。

**请求行**包括如下字段：
- 方法（Method）：指定要执行的操作，如 GET、POST、PUT、DELETE 等。
- 资源路径（Resource Path）：请求的资源的URI（统一资源标识符）。
- HTTP版本（HTTP Version）：使用的HTTP协议版本，如 HTTP/1.1 或 HTTP/2.0。

**请求头**的字段较多，常使用的包含以下几个：
- Host：请求的服务器的域名。
- Accept：客户端能够处理的媒体类型。
- Accept-Encoding：客户端能够解码的内容编码。
- Authorization：用于认证的凭证信息，比如token数据。
- Content-Length：请求体的长度。
- Content-Type：请求体的媒体类型。
- Cookie：存储在客户端的cookie数据。
- If-None-Match：资源的ETag值，用于缓存控制。
- Connection：管理连接的选项，如 keep-alive。

空行是请求头部和请求主体之间的空行，用于分隔请求头部和请求主体。而请求体通常用于 POST 和 PUT 请求，包含发送给服务器的数据。

#### （2）响应报文

HTTP响应报文是服务器向客户端返回的数据格式，用于传达服务器对客户端请求的处理结果以及相关的数据。一个标准的HTTP响应报文通常包含状态行、响应头、空行、响应体。

状态行包含HTTP版本、状态码和状态消息。例如：HTTP/1.1 200 OK

**响应头部**也是以键值对的形式提供的额外信息，类似于请求头部，用于告知客户端有关响应的详细信息。一些常见的响应头部字段包括：
- Content-Type：指定响应主体的媒体类型。
- Content-Length：指定响应主体的长度（字节数）。
- Server：指定服务器的信息。
- Expires: 响应的过期时间，之后内容被认为是过时的。
- ETag: 响应体的实体标签，用于缓存和条件请求。
- Last-Modified：资源最后被修改的日期和时间。
- Location：在重定向时指定新的资源位置。
- Set-Cookie：在响应中设置Cookie。
- Access-Control-Allow-Origin: 跨源资源共享（CORS）策略，指示哪些域可以访问资源。

空行（Empty Line）在响应头和响应体之间，表示响应头的结束。而响应体是服务端实际传输的数据，可以是文本、HTML页面、图片、视频等，也可能为空。

### HTTP有哪些请求方式？GET请求和POST请求的区别

#### HTTP请求方式：

1. GET：请求指定的资源。
2. POST：向指定资源提交数据进行处理请求（例如表单提交）。
3. PUT：更新指定资源。
4. DELETE：删除指定资源。
5. HEAD：获取报文首部，不返回报文主体。
6. OPTIONS：查询服务器支持的请求方法。
7. PATCH：对资源进行部分更新。

#### GET请求和POST请求的区别：

1. 用途：GET请求通常用于获取数据，POST请求用于提交数据。
2. 数据传输：GET请求将参数附加在URL之后，POST请求将数据放在请求体中。
3. 安全性：GET请求由于参数暴露在URL中，安全性较低；POST请求参数不会暴露在URL中，相对更安全。
4. 数据大小：GET请求受到URL长度限制，数据量有限；POST请求理论上没有大小限制。
5. 幂等性：GET请求是幂等的，即多次执行相同的GET请求，资源的状态不会改变；POST请求不是幂等的，因为每次提交都可能改变资源状态。
6. 缓存：GET请求可以被缓存，POST请求默认不会被缓存。

### HTTP请求中常见的状态码

| 状态码 | 含义 |
|--------|------|
| 1XX | 提示信息，协议处理的中间状态 |
| 200 | 成功，服务器已成功处理了请求 |
| 201 | 已创建，请求成功并且服务器创建了新的资源 |
| 202 | 已接受，服务器已接受请求，但尚未处理 |
| 204 | 无内容，服务器成功处理了请求，但没有返回任何内容 |
| 206 | 部分内容，服务器返回的BODY数据是资源的一部分 |
| 301 | 永久重定向，请求的网页已永久移动到新位置 |
| 302 | 临时重定向，说明请求的资源还在，但暂时需要用另一个URL来访问 |
| 304 | 未修改，自从上次请求后，请求的网页未修改过 |
| 401 | 未授权，请求要求身份验证 |
| 403 | 禁止，服务器拒绝请求 |
| 404 | 未找到，服务器找不到请求的网页 |
| 500 | 服务器内部错误 |
| 501 | 尚未实施，服务器不具备完成请求的功能 |
| 502 | 错误网关，服务器作为网关或代理，从上游服务器收到无效响应 |
| 503 | 服务不可用，服务器目前无法使用 |
| 504 | 网关超时，服务器作为网关或代理，但是没有及时从上游服务器收到请求 |

**HTTP请求中常用的状态码包括以下几个：**
- 200：表示客户端请求成功
- 201：创建了新资源
- 204：无内容，服务器成功处理请求，但未返回任何内容
- 301：永久重定向
- 302：临时重定向
- 304：请求的内容没有修改过，所以服务器返回此响应时，不会返回网页内容，而是使用缓存
- 401：请求需要身份验证
- 403：请求的对应资源禁止被访问
- 404：服务器无法找到对应资源
- 500：服务器内部错误
- 503：服务不可用

### 什么是强缓存和协商缓存

强缓存和协商缓存是HTTP缓存机制的两种类型，它们用于减少服务器的负担和提高网页加载速度。

#### 强缓存

客户端在没有向服务器发送请求的情况下，直接从本地缓存中获取资源。

- **Expires强缓存**：设置一个强缓存时间，此时间范围内，从内存中读取缓存并返回。但是因为Expires判断强缓存过期的机制是获取本地时间戳，与之前拿到的资源文件中的Expires字段的时间做比较来判断是否需要对服务器发起请求。这里有一个巨大的漏洞："如果我本地时间不准咋办？"所以目前已经被废弃了。

- **Cache-Control强缓存**：目前使用的强缓存是通过HTTP响应头中的Cache-Control字段实现，通过max-age来告诉浏览器在指定时间内可以直接使用缓存数据，无需再次请求。

#### 协商缓存

当强缓存失效时，浏览器会发送请求到服务器，通过ETag或Last-Modified等HTTP响应头与服务器进行验证，以确定资源是否被修改。如果资源未修改，服务器返回304 Not Modified状态码，告知浏览器使用本地缓存；如果资源已修改，则返回新的资源，浏览器更新本地缓存。这种方式需要与服务器通信，但可以确保用户总是获取最新的内容。

- **基于Last-Modified的协商缓存**
  - Last-Modified 是资源的最后修改时间，服务器在响应头部中返回。
  - 当客户端读取到Last-modified的时候，会在下次的请求标头中携带一个字段:If-Modified-Since，而这个请求头中的If-Modified-Since就是服务器第一次修改时候给他的时间。
  - 服务器比较请求中的 If-Modified-Since 值与当前资源的 Last-Modified 值，如果比对的结果是没有变化，表示资源未发生变化，返回状态码 304 Not Modified。如果比对的结果说资源已经更新了，就会给浏览器正常返回资源，返回200状态。
  - 缺点：
    - 因为是更改文件修改时间来判断的，所以在文件内容本身不修改的情况下，依然有可能更新文件修改时间（比如修改文件名再改回来），这样，就有可能文件内容明明没有修改，但是缓存依然失效了。
    - 当文件在极短时间内完成修改的时候（比如几百毫秒）。因为文件修改时间记录的最小单位是秒，所以，如果文件在几百毫秒内完成修改的话，文件修改时间不会改变，这样，即使文件内容修改了，依然不会返回新的文件。

- **基于ETag的协商缓存**：将原先协商缓存的比较时间戳的形式修改成了比较文件指纹（根据文件内容计算出的唯一哈希值）。
  - ETag 是服务器为资源生成的唯一标识符（文件指纹），可以是根据文件内容计算出的哈希值，服务端将其和资源一起放回给客户端。
  - 客户端在请求头部的 If-None-Match 字段中携带上次响应的 ETag 值。
  - 服务器比较请求中的 If-None-Match 值与当前资源的 ETag 值，如果匹配，表示资源未发生变化，返回状态码 304 Not Modified。如果两个文件指纹不吻合，则说明文件被更改，那么将新的文件指纹重新存储到响应头的ETag中并返回给客户端。

### HTTP1.0和HTTP1.1的区别

1. 持久连接：HTTP/1.1 默认支持持久连接，允许在一个TCP连接上发送多个HTTP请求和响应，减少了连接建立和关闭的开销。而HTTP/1.0 默认为短连接，每次请求都需要建立一个TCP连接，并通过Connection: keep-alive头来实现持久连接。

2. 管道化：HTTP/1.1 支持管道化，允许客户端在第一个请求的响应到达之前发送多个请求，这可以减少等待时间，提高效率。HTTP/1.0不支持管道化。

3. 缓存控制：HTTP1.0主要使用If-Modified-Since/Expires来做为缓存判断的标准，而HTTP1.1则引入了更多的缓存控制策略例如Etag / If-None-Match等更多可供选择的缓存头来控制缓存策略。

4. 错误处理：HTTP/1.1 增加了一些新的HTTP状态码，如100 Continue，用于增强错误处理和请求的中间响应。

5. Host 头：HTTP/1.1 引入了Host头，允许客户端指定请求的主机名，这使得在同一台服务器上托管多个域名成为可能。HTTP/1.0没有这个头字段。

6. 带宽优化：HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，而HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content）。

### HTTP2.0与HTTP1.1的区别？

1. 二进制协议：HTTP/2.0 采用二进制格式传输数据，而非HTTP/1.1 的文本格式，使得解析更高效，减少了解析时间。

2. 多路复用：HTTP/2.0 支持多路复用，允许在单个TCP连接上并行交错发送多个请求和响应，解决了HTTP/1.1 中的队头阻塞问题。

3. 头部压缩：HTTP/2.0 引入了HPACK 压缩算法，对请求和响应的头部信息进行压缩，减少了冗余头部信息的传输，提高了传输效率。

4. 服务器推送：HTTP/2.0 允许服务器主动推送资源给客户端，而不需要客户端明确请求，这可以减少页面加载时间。

5. 优先级和依赖：HTTP/2.0 允许客户端为请求设置优先级，并表达请求之间的依赖关系，资源加载更加有序。

### HTTP3.0有了解过吗？

HTTP/3是HTTP协议的最新版本，它基于QUIC协议，具有以下特点：

1. 无队头阻塞：QUIC 使用UDP协议来传输数据。一个连接上的多个stream之间没有依赖，如果一个stream丢了一个UDP包，不会影响后面的stream，不存在队头阻塞问题。

2. 零RTT连接建立：首次连接肯定是需要1 RTT的，0 RTT的优势是在连接的后续建立的，从而减少了连接延迟，加快了页面加载速度。

3. 连接迁移：QUIC 允许在网络切换（如从 Wi-Fi 到移动网络）时，将连接迁移到新的 IP 地址，从而减少连接的中断时间。

4. 优化的可靠性机制（取代早期 FEC）：前向纠错（FEC）的演进，早期 QUIC（gQUIC）曾引入 FEC，通过数据包冗余减少重传，但因协议复杂度和带宽成本过高，在 IETF 标准化版本（RFC 9000）中被移除。当前方案依赖选择性重传（SACK）、自适应拥塞控制及快速丢包检测保障可靠性，同时通过流优先级和流量控制优化资源分配。

5. 安全性：HTTP/3默认使用TLS加密，确保了数据传输的安全性。

### HTTPS和HTTP有哪些区别

两者的主要区别在于安全性和数据加密：

1. 加密层：HTTPS 在HTTP 的基础上增加了SSL/TLS 协议作为加密层，确保数据传输的安全性。

2. 数据安全：HTTPS 通过加密，保护数据在传输过程中不被窃听或篡改，而HTTP 数据传输是明文的，容易受到攻击。

3. 端口：HTTPS 通常使用端口443 ，而HTTP 使用端口80。

### HTTPS工作原理

HTTPS 主要基于SSL/TLS 协议，确保了数据传输的安全性和完整性，其建立连接并传输数据的过程如下：

1. 密钥交换：客户端发起HTTPS请求后，服务器会发送其公钥证书给客户端。

2. 证书验证：客户端会验证服务器的证书是否由受信任的证书颁发机构（CA）签发，并检查证书的有效性。

3. 加密通信：一旦证书验证通过，客户端会生成一个随机的对称加密密钥，并使用服务器的公钥加密这个密钥，然后发送给服务器。

4. 建立安全连接：服务器使用自己的私钥解密得到对称加密密钥，此时客户端和服务器都有了相同的密钥，可以进行加密和解密操作。

5. 数据传输：使用对称加密密钥对所有传输的数据进行加密，确保数据在传输过程中的安全性。

6. 完整性校验：SSL/TLS协议还包括消息完整性校验机制，如消息认证码，确保数据在传输过程中未被篡改。

7. 结束连接：数据传输完成后，通信双方会进行会话密钥的销毁，以确保不会留下安全隐患。

### TCP和UDP的区别

1. TCP是面向连接的协议，需要在数据传输前建立连接；UDP是无连接的，不需要建立连接。

2. TCP提供可靠的数据传输，保证数据包的顺序和完整性；UDP不保证数据包的顺序或完整性。

3. TCP具有拥塞控制机制，可以根据网络状况调整数据传输速率；UDP没有拥塞控制，发送速率通常固定。

4. TCP通过滑动窗口机制进行流量控制，避免接收方处理不过来；UDP没有流量控制。

5. TCP能够检测并重传丢失或损坏的数据包；UDP不提供错误恢复机制。

6. TCP有复杂的报文头部，包含序列号、确认号等信息；UDP的报文头部相对简单。

7. 由于TCP的连接建立、数据校验和重传机制，其性能开销通常比UDP大；UDP由于简单，性能开销小。

8. 适用场景：TCP适用于需要可靠传输的应用，如网页浏览、文件传输等；UDP适用于对实时性要求高的应用，如语音通话、视频会议等。

### TCP连接如何确保可靠性

TCP通过序列号、确认应答、超时重传、数据校验、流量控制、拥塞控制等机制，确保了数据传输的可靠性和效率。

1. 序列号：每个TCP段都有一个序列号，确保数据包的顺序正确。

2. 确认应答：接收方发送ACK确认收到的数据，如果发送方在一定时间内没有收到确认，会重新发送数据。

3. 超时重传：发送方设置一个定时器，如果在定时器超时之前没有收到确认，发送方会重传数据。

4. 数据校验：TCP使用校验和来检测数据在传输过程中是否出现错误，如果检测到错误，接收方会丢弃该数据包，并等待重传。

5. 流量控制：TCP通过滑动窗口机制进行流量控制，确保接收方能够处理发送方的数据量。

6. 拥塞控制：TCP通过算法如慢启动、拥塞避免、快重传和快恢复等，来控制数据的发送速率，防止网络拥塞。

### TCP拥塞控制机制

TCP拥塞控制可以在网络出现拥塞时动态地调整数据传输的速率，以防止网络过载。TCP拥塞控制的主要机制包括以下几个方面：

1. 慢启动（Slow Start）：初始阶段，TCP发送方会以较小的发送窗口开始传输数据。随着每次成功收到确认的数据，发送方逐渐增加发送窗口的大小，实现指数级的增长，这称为慢启动。这有助于在网络刚开始传输时谨慎地逐步增加速率，以避免引发拥塞。

2. 拥塞避免（Congestion Avoidance）：一旦达到一定的阈值（通常是慢启动阈值），TCP发送方就会进入拥塞避免阶段。在拥塞避免阶段，发送方以线性增加的方式增加发送窗口的大小，而不再是指数级的增长。这有助于控制发送速率，以避免引起网络拥塞。

3. 快速重传（Fast Retransmit）：如果发送方连续收到相同的确认，它会认为发生了数据包的丢失，并会快速重传未确认的数据包，而不必等待超时。这有助于更快地恢复由于拥塞引起的数据包丢失。

4. 快速恢复（Fast Recovery）：在发生快速重传后，TCP进入快速恢复阶段。在这个阶段，发送方不会回到慢启动阶段，而是将慢启动阈值设置为当前窗口的一半，并将拥塞窗口大小设置为慢启动阈值加上已确认但未被快速重传的数据块的数量。这有助于更快地从拥塞中恢复。

### TCP流量控制机制

流量控制就是让发送方发送速率不要过快，让接收方来得及接收。利用滑动窗口机制就可以实施流量控制，主要方法就是动态调整发送方和接收方之间数据传输速率。

- 滑动窗口大小：在TCP通信中，每个TCP报文段都包含一个窗口字段，该字段指示发送方可以发送多少字节的数据而不等待确认。这个窗口大小是动态调整的。

- 接收方窗口大小：接收方通过TCP报文中的窗口字段告诉发送方自己当前的可接收窗口大小。这是接收方缓冲区中还有多少可用空间。

- 流量控制的目标：流量控制的目标是确保发送方不要发送超过接收方缓冲区容量的数据。如果接收方的缓冲区快满了，它会减小窗口大小，通知发送方暂停发送，以防止溢出。

- 动态调整：发送方会根据接收方的窗口大小动态调整发送数据的速率。如果接收方的窗口大小增加，发送方可以加速发送数据。如果窗口大小减小，发送方将减缓发送数据的速率。

- 确认机制：接收方会定期发送确认（ACK）报文，告知发送方已成功接收数据。这也与流量控制密切相关，因为接收方可以通过ACK报文中的窗口字段来通知发送方它的当前窗口大小。

### UDP怎么实现可靠传输

UDP它不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用UDP较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。关键在于两点，从应用层角度考虑：

1. 提供超时重传，能避免数据报丢失。
2. 提供确认序列号，可以对数据报进行确认和排序。

**本端**：首先在UDP数据报定义一个首部，首部包含确认序列号和时间戳，时间戳是用来计算RTT(数据报传输的往返时间)，计算出合适的RTO(重传的超时时间)。然后以等-停的方式发送数据报，即收到对端的确认之后才发送下一个的数据报。当时间超时，本端重传数据报，同时RTO扩大为原来的两倍，重新开始计时。

**对端**：接受到一个数据报之后取下该数据报首部的时间戳和确认序列号，并添加本端的确认数据报首部之后发送给对段。根据此序列号对已收到的数据报进行排序并丢弃重复的数据报。

### 三次握手的过程，为什么是三次

#### （1）三次握手的过程

1. 第一次握手：客户端向服务器发送一个SYN（同步序列编号）报文，请求建立连接，客户端进入SYN_SENT状态。

2. 第二次握手：服务器收到SYN 报文后，如果同意建立连接，则会发送一个SYN-ACK（同步确认）报文作为响应，同时进入SYN_RCVD状态。

3. 第三次握手：客户端收到服务器的SYN-ACK 报文后，会发送一个ACK（确认）报文作为最终响应，之后客户端和服务器都进入ESTABLISHED状态，连接建立成功。

#### （2）为什么需要三次握手

通过三次握手，客户端和服务器都能够确认对方的接收和发送能力。第一次握手确认了客户端到服务器的通道是开放的；第二次握手确认了服务器到客户端的通道是开放的；第三次握手则确认了客户端接收到服务器的确认，从而确保了双方的通道都是可用的。

而如果仅使用两次握手，服务器可能无法确定客户端的接收能力是否正常，比如客户端可能已经关闭了连接，但之前发送的连接请求报文在网络上延迟到达了服务器，服务器就会主动去建立一个连接，但是客户端接收不到，导致资源的浪费。而四次握手可以优化为三次。

### 四次挥手的过程，为什么是四次

#### （1）四次挥手的过程

1. 第一次挥手：客户端发送一个FIN报文给服务端，表示自己要断开数据传送，报文中会指定一个序列号 (seq=x)。然后，客户端进入FIN-WAIT-1状态。

2. 第二次挥手：服务端收到FIN报文后，回复ACK报文给客户端，且把客户端的序列号值+1，作为ACK+1报文的序列号(seq=x+1)。然后，服务端进入CLOSE-WAIT状态，客户端进入FIN-WAIT-2状态。

3. 第三次挥手：服务端也要断开连接时，发送FIN报文给客户端，且指定一个序列号(seq=y+1)，随后服务端进入LAST-ACK状态。

4. 第四次挥手：客户端收到FIN报文后，发出ACK报文进行应答，并把服务端的序列号值+1作为ACK报文序列号(seq=y+2)。此时客户端进入TIME-WAIT状态。服务端在收到客户端的ACK报文后进入CLOSE状态。如果客户端等待2MSL没有收到回复，才关闭连接。

#### （2）为什么需要四次挥手

TCP是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后才会完全关闭TCP连接。因此两次握手可以释放一端到另一端的TCP连接，完全释放连接一共需要四次握手。

只有通过四次挥手，才可以确保双方都能接收到对方的最后一个数据段的确认，主动关闭方在发送完最后一个ACK后进入TIME-WAIT状态，这是为了确保被动关闭方接收到最终的ACK，如果被动关闭方没有接收到，它可以重发FIN报文，主动关闭方可以再次发送ACK。

而如果使用三次挥手，被动关闭方可能在发送最后一个数据段后立即关闭连接，而主动关闭方可能还没有接收到这个数据段的确认。

### HTTP的Keep-Alive是什么？TCP的Keepalive和HTTP的Keep-Alive是一个东西吗？

1. **HTTP的Keep-Alive**，是由应用层实现的，称为HTTP长连接。

   每次请求都要经历这样的过程：建立TCP连接 -> HTTP请求资源 -> 响应资源 -> 释放连接，这就是HTTP短连接，但是这样每次建立连接都只能请求一次资源，所以HTTP的Keep-Alive实现了使用同一个TCP连接来发送和接收多个HTTP请求/应答，这就是HTTP长连接。通过设置HTTP头Connection: keep-alive来实现。

2. **TCP的Keepalive**，是由TCP层（内核态）实现的，称为TCP保活机制，是一种用于在TCP连接上检测空闲连接状态的机制。

   当TCP连接建立后，如果一段时间内没有任何数据传输，TCP Keepalive会发送探测包来检查连接是否仍然有效。

### DNS查询过程

DNS用来将主机名和域名转换为IP地址，其查询过程一般通过以下步骤：

1. 本地DNS缓存检查：首先查询本地DNS缓存，如果缓存中有对应的IP地址，则直接返回结果。

2. 如果本地缓存中没有，则会向本地的DNS服务器（通常由你的互联网服务提供商（ISP）提供，比如中国移动）发送一个DNS查询请求。

3. 如果本地DNS解析器有该域名的ip地址，就会直接返回，如果没有缓存该域名的解析记录，它会向根DNS服务器发出查询请求。根DNS服务器并不负责解析域名，但它能告诉本地DNS解析器应该向哪个顶级域（.com/.net/.org）的DNS服务器继续查询。

4. 本地DNS解析器接着向指定的顶级域名DNS服务器发出查询请求。顶级域DNS服务器也不负责具体的域名解析，但它能告诉本地DNS解析器应该前往哪个权威DNS服务器查询下一步的信息。

5. 本地DNS解析器最后向权威DNS服务器发送查询请求。权威DNS服务器是负责存储特定域名和IP地址映射的服务器。当权威DNS服务器收到查询请求时，它会查找域名对应的IP地址，并将结果返回给本地DNS解析器。

6. 本地DNS解析器将收到的IP地址返回给浏览器，并且还会将域名解析结果缓存在本地，以便下次访问时更快地响应。

7. 浏览器发起连接：本地DNS解析器已经将IP地址返回给您的计算机，您的浏览器可以使用该IP地址与目标服务器建立连接，开始获取网页内容。

### CDN是什么

CDN是一种分布式网络服务，通过将内容存储在分布式的服务器上，使用户可以从距离较近的服务器获取所需的内容，从而加速互联网上的内容传输。

- 就近访问：CDN在全球范围内部署了多个服务器节点，用户的请求会被路由到距离最近的CDN节点，提供快速的内容访问。

- 内容缓存：CDN节点会缓存静态资源，如图片、样式表、脚本等。当用户请求访问这些资源时，CDN会首先检查是否已经缓存了该资源。如果有缓存，CDN节点会直接返回缓存的资源，如果没有缓存所需资源，它会从源服务器（原始服务器）回源获取资源，并将资源缓存到节点中，以便以后的请求。通过缓存内容，减少了对原始服务器的请求，减轻了源站的负载。

- 可用性：即使某些节点出现问题，用户请求可以被重定向到其他健康的节点。

### Cookie和Session是什么？有什么区别？

#### （1）Cookie和Session是什么？

Cookie和Session都用于管理用户的状态和身份，Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。

**Cookie**
- 通常，服务器会将一个或多个Cookie发送到用户浏览器，然后浏览器将这些Cookie存储在本地。
- 服务器在接收到来自客户端浏览器的请求之后，就能够通过分析存放于请求头的Cookie得到客户端特有的信息，从而动态生成与该客户端相对应的内容。

**Session**

客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。Session主要用于维护用户登录状态、存储用户的临时数据和上下文信息等。服务器为每个用户分配一个唯一的Session ID，通常存储在Cookie中。

#### （2）Cookie和Session的区别？

- 存储位置：Cookie数据存储在用户的浏览器中，而Session数据存储在服务器上。
- 数据容量：Cookie存储容量较小，一般为几KB。Session存储容量较大，通常没有固定限制，取决于服务器的配置和资源。
- 安全性：由于Cookie存储在用户浏览器中，因此可以被用户读取和篡改。相比之下，Session数据存储在服务器上，更难被用户访问和修改。
- 生命周期：Cookie可以设置过期时间，Session依赖于会话的持续时间或用户活动。
- 传输方式：Cookie在每次HTTP请求中都会被自动发送到服务器，而Session ID通常通过Cookie或URL参数传递。

---

## 操作系统

### 进程和线程的区别

进程是资源分配和调度的基本单位。

线程是程序执行的最小单位，线程是进程的子任务，是进程内的执行单元。一个进程至少有一个线程，一个进程可以运行多个线程，这些线程共享同一块内存。

#### 资源开销：
- 进程：由于每个进程都有独立的内存空间，创建和销毁进程的开销较大。进程间切换需要保存和恢复整个进程的状态，因此上下文切换的开销较高。
- 线程：线程共享相同的内存空间，创建和销毁线程的开销较小。线程间切换只需要保存和恢复少量的线程上下文，因此上下文切换的开销较小。

#### 通信与同步：
- 进程：由于进程间相互隔离，进程之间的通信需要使用一些特殊机制，如管道、消息队列、共享内存等。
- 线程：由于线程共享相同的内存空间，它们之间可以直接访问共享数据，线程间通信更加方便。

#### 安全性：
- 进程：由于进程间相互隔离，一个进程的崩溃不会直接影响其他进程的稳定性。
- 线程：由于线程共享相同的内存空间，一个线程的错误可能会影响整个进程的稳定性。

### 并行和并发有什么区别

- 并行是在同一时刻执行多个任务。
- 并发是在相同的时间段内执行多个任务，任务可能交替执行，通过调度实现。

并行是指在同一时刻执行多个任务，这些任务可以同时进行，每个任务都在不同的处理单元（如多个CPU核心）上执行。在并行系统中，多个处理单元可以同时处理独立的子任务，从而加速整体任务的完成。

并发是指在相同的时间段内执行多个任务，这些任务可能不是同时发生的，而是交替执行，通过时间片轮转或者事件驱动的方式。并发通常与任务之间的交替执行和任务调度有关。

### 解释一下用户态和核心态

#### 用户态和内核态的区别

用户态和内核态是操作系统为了保护系统资源和实现权限控制而设计的两种不同的CPU运行级别，可以控制进程或程序对计算机硬件资源的访问权限和操作范围。

- 用户态：在用户态下，进程或程序只能访问受限的资源和执行受限的指令集，不能直接访问操作系统的核心部分，也不能直接访问硬件资源。
- 核心态：核心态是操作系统的特权级别，允许进程或程序执行特权指令和访问操作系统的核心部分。在核心态下，进程可以直接访问硬件资源，执行系统调用，管理内存、文件系统等操作。

#### 在什么场景下，会发生内核态和用户态的切换

- 系统调用：当用户程序需要请求操作系统提供的服务时，会通过系统调用进入内核态。
- 异常：当程序执行过程中出现错误或异常情况时，CPU会自动切换到内核态，以便操作系统能够处理这些异常。
- 中断：外部设备（如键盘、鼠标、磁盘等）产生的中断信号会使CPU从用户态切换到内核态。操作系统会处理这些中断，执行相应的中断处理程序，然后再将CPU切换回用户态。

### 进程调度算法你了解多少

- 先来先服务：按照请求的顺序进行调度。这种调度方式简单，但是能导致较长作业阻塞较短作业。
- 最短作业优先：非抢占式的调度算法，按估计运行时间最短的顺序进行调度。但是如果一直有短作业到来，那么长作业永远得不到调度，造成长作业"饥饿"现象。
- 最短剩余时间优先：基于最短作业优先改进，按剩余运行时间的顺序进行调度。当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。
- 优先级调度：为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。
- 时间片轮转：为每个进程分配一个时间片，进程轮流执行，时间片用完后切换到下一个进程。
- 多级队列：时间片轮转调度算法和优先级调度算法的结合。将进程分为不同的优先级队列，每个队列有自己的调度算法。

### 进程间有哪些通信方式

1. 管道：是一种半双工的通信方式，数据只能单向流动而且只能在具有父子进程关系的进程间使用。
2. 命名管道：类似管道，也是半双工的通信方式，但是它允许在不相关的进程间通信。
3. 消息队列：允许进程发送和接收消息，而消息队列是消息的链表，可以设置消息优先级。
4. 信号：用于发送通知到进程，告知其发生了某种事件或条件。
5. 信号量：是一个计数器，可以用来控制多个进程对共享资源的访问，常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此主要作为进程间以及同一进程内不同线程之间的同步手段。
6. 共享内存：就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的进程通信方式。
7. Socket套接字：是支持TCP/IP的网络通信的基本操作单元，主要用于在客户端和服务器之间通过网络进行通信。
8. 互斥锁：一种信号量，用于保护共享数据结构，防止多个进程同时访问。
9. 条件变量：与互斥锁配合使用，用于进程间的同步，等待某些条件成立。

### 解释一下进程同步和互斥，以及如何实现进程同步和互斥

进程同步是指多个并发执行的进程之间协调和管理它们的执行顺序，以确保它们按照一定的顺序或时间间隔执行。

互斥指的是在某一时刻只允许一个进程访问某个共享资源。当一个进程正在使用共享资源时，其他进程不能同时访问该资源。

解决进程同步和互斥的问题有很多种方法，其中一种常见的方法是使用信号量和PV操作。信号量是一种特殊的变量，它表示系统中某种资源的数量或者状态。PV操作是一种对信号量进行增加或者减少的操作，它们可以用来控制进程之间的同步或者互斥。

- P操作：相当于"检查"信号量，如果资源可用，就减少计数，然后使用资源。
- V操作：相当于"归还"资源，增加信号量的计数，并可能唤醒等待的进程。

除此之外，下面的方法也可以解决进程同步和互斥问题：

- 临界区：将可能引发互斥问题的代码段称为临界区，里面包含了需要互斥访问的资源。进入这个区域前需要先获取锁，退出临界区后释放该锁。这确保同一时间只有一个进程可以进入临界区。
- 互斥锁（Mutex）：互斥锁是一种同步机制，用于实现互斥。每个共享资源都关联一个互斥锁，进程在访问该资源前需要先获取互斥锁，使用完后释放锁。只有获得锁的进程才能访问共享资源。
- 条件变量：条件变量用于在进程之间传递信息，以便它们在特定条件下等待或唤醒。通常与互斥锁一起使用，以确保等待和唤醒的操作在正确的时机执行。

### 什么是死锁，如何预防死锁？

死锁是系统中两个或多个进程在执行过程中，因争夺资源而造成的一种僵局。当每个进程都持有一定的资源并等待其他进程释放它们所需的资源时，如果这些资源都被其他进程占有且不释放，就导致了死锁。

死锁只有同时满足以下四个条件才会发生：
- 互斥条件：一个进程占用了某个资源时，其他进程无法同时占用该资源。
- 请求保持条件：一个线程因为请求资源而阻塞的时候，不会释放自己的资源。
- 不可剥夺条件：资源不能被强制性地从一个进程中剥夺，只能由持有者自愿释放。
- 循环等待条件：多个进程之间形成一个循环等待资源的链，每个进程都在等待下一个进程所占有的资源。

**避免死锁**：通过破坏死锁的四个必要条件之一来预防死锁。比如破坏循环等待条件，让所有进程按照相同的顺序请求资源。

**检测死锁**：通过检测系统中的资源分配情况来判断是否存在死锁。例如，可以使用资源分配图或银行家算法进行检测。

**解除死锁**：一旦检测到死锁存在，可以采取一些措施来解除死锁。例如，可以通过抢占资源、终止某些进程或进行资源回收等方式来解除死锁。

### 讲一讲你理解的虚拟内存

虚拟内存是指在每一个进程创建加载的过程中，会分配一个连续虚拟地址空间，它不是真实存在的，而是通过映射与实际物理地址空间对应，这样就可以使每个进程看起来都有自己独立的连续地址空间，并允许程序访问比物理内存RAM更大的地址空间，每个程序都可以认为它拥有足够的内存来运行。

#### 需要虚拟内存的原因：

- 内存扩展：虚拟内存使得每个程序都可以使用比实际可用内存更多的内存，从而允许运行更大的程序或处理更多的数据。
- 内存隔离：虚拟内存还提供了进程之间的内存隔离。每个进程都有自己的虚拟地址空间，因此一个进程无法直接访问另一个进程的内存。
- 物理内存管理：虚拟内存允许操作系统动态地将数据和程序的部分加载到物理内存中，以满足当前正在运行的进程的需求。当物理内存不足时，操作系统可以将不常用的数据或程序暂时移到硬盘上，从而释放内存，以便其他进程使用。
- 页面交换：当物理内存不足时，操作系统可以将一部分数据从物理内存写入到硬盘的虚拟内存中，这个过程被称为页面交换。当需要时，数据可以再次从虚拟内存中加载到物理内存中。这样可以保证系统可以继续运行，尽管物理内存有限。
- 内存映射文件：虚拟内存还可以用于将文件映射到内存中，这使得文件的读取和写入可以像访问内存一样高效。

### 你知道的线程同步的方式有哪些？

线程同步机制是指在多线程编程中，为了保证线程之间的互不干扰，而采用的一种机制。常见的线程同步机制有以下几种：

1. 互斥锁：互斥锁是最常见的线程同步机制。它允许只有一个线程同时访问被保护的临界区（共享资源）
2. 条件变量：条件变量用于线程间通信，允许一个线程等待某个条件满足，而其他线程可以发出信号通知等待线程。通常与互斥锁一起使用。
3. 读写锁：读写锁允许多个线程同时读取共享资源，但只允许一个线程写入资源。
4. 信号量：用于控制多个线程对共享资源进行访问的工具。

### 介绍一下几种典型的锁

- 互斥锁：互斥锁是一种最常见的锁类型，用于实现互斥访问共享资源。在任何时刻，只有一个线程可以持有互斥锁，其他线程必须等待直到锁被释放。这确保了同一时间只有一个线程能够访问被保护的资源。
- 自旋锁：自旋锁是一种基于忙等待的锁，即线程在尝试获取锁时会不断轮询，直到锁被释放。

其他的锁都是基于这两个锁的：
- 读写锁：允许多个线程同时读共享资源，只允许一个线程进行写操作。分为读（共享）和写（排他）两种状态。
- 悲观锁：认为多线程同时修改共享资源的概率比较高，所以访问共享资源时候要上锁。
- 乐观锁：先不管，修改了共享资源再说，如果出现同时修改的情况，再放弃本次操作。

### 有哪些页面置换算法

常见页面置换算法有最佳置换算法（OPT）、先进先出（FIFO）、最近最久未使用算法（LRU）、时钟算法（Clock）等。

1. 最近最久未使用算法LRU：LRU算法基于页面的使用历史，通过选择最长时间未被使用的页面进行置换。
2. 先进先出FIFO算法：也就是最先进入内存的页面最先被置换出去。
3. 最不经常使用LFU：淘汰访问次数最少的页面，考虑页面的访问频率。
4. 时钟算法CLOCK：Clock算法的核心思想是通过使用一个指针(称为时钟指针)在环形链表上遍历，检查页面是否被访问过。当需要进行页面置换时，Clock算法从时钟指针的位置开始遍历环形链表。如果当前页面的访问位为0，表示该页面最久未被访问，可以选择进行置换。将访问位设置为1，继续遍历下一个页面。如果当前页面的访问位为1，表示该页面最近被访问过，它仍然处于活跃状态。将访问位设置为0，并继续遍历下一个页面。如果遍历过程中找到一个访问位为0的页面，那么选择该页面进行置换。
5. 最佳置换算法：该算法根据未来的页面访问情况，选择最长时间内不会被访问到的页面进行置换。那么就有一个问题了，未来要访问什么页面，操作系统怎么知道的呢?操作系统当然不会知道，所以这种算法只是一种理想情况下的置换算法，通常是无法实现的。

### select、poll、epoll的区别

I/O多路复用通常通过select、poll、epoll等系统调用来实现。

- select：select是一个最古老的I/O多路复用机制，它可以监视多个文件描述符的可读、可写和错误状态。但是它的效率可能随着监视的文件描述符数量的增加而降低。
- poll：poll是select的一种改进，它使用轮询方式来检查多个文件描述符的状态，避免了select中文件描述符数量有限的问题。但对于大量的文件描述符，poll的性能也可能变得不足够高效。
- epoll：epoll是Linux特有的I/O多路复用机制，相较于select和poll，它在处理大量文件描述符时更加高效。epoll使用事件通知的方式，只有在文件描述符就绪时才会通知应用程序，而不需要应用程序轮询。

I/O多路复用允许在一个线程中处理多个I/O操作，避免了创建多个线程或进程的开销，允许在一个线程中处理多个I/O操作，避免了创建多个线程或进程的开销。

---

## 数据库

### 一条SQL查询语句是如何执行的？

1. 连接器：连接器负责跟客户端建立连接、获取权限、维持和管理连接。

2. 查询缓存：MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。

3. 分析器：你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么。

4. 优化器：优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联(join)的时候，决定各个表的连接顺序。

5. 执行器：MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。

### 数据库的事务隔离级别有哪些？

1. 读未提交（Read Uncommitted）：
   - 允许一个事务读取另一个事务尚未提交的数据修改。
   - 最低的隔离级别，存在脏读、不可重复读和幻读的问题。

2. 读已提交（Read Committed）：
   - 一个事务只能读取已经提交的数据。其他事务的修改在该事务提交之后才可见。
   - 解决了脏读问题，但仍可能出现不可重复读和幻读。

3. 可重复读（Repeatable Read）：
   - 事务执行期间，多次读取同一数据会得到相同的结果，即在事务开始和结束之间，其他事务对数据的修改不可见。
   - 解决了不可重复读问题，但仍可能出现幻读。

4. 序列化（Serializable）：
   - 最高的隔离级别，确保事务之间的并发执行效果与串行执行的效果相同，即不会出现脏读、不可重复读和幻读。

### 事务的四大特性有哪些？

事务的四大特性通常被称为ACID特性：

1. 原子性：确保事务的所有操作要么全部执行成功，要么全部失败回滚，不存在部分成功的情况。
2. 一致性：事务在执行前后，数据库从一个一致性状态转变到另一个一致性状态。
3. 隔离性：多个事务并发执行时，每个事务都应该被隔离开来，一个事务的执行不应该影响其他事务的执行。
4. 持久性：一旦事务被提交，它对数据库的改变就是永久性的，即使在系统故障或崩溃后也能够保持。

### MySQL的执行引擎有哪些？

MySQL的执行引擎主要负责查询的执行和数据的存储，其执行引擎主要有MyISAM、InnoDB、Memory等。

- InnoDB引擎提供了对事务ACID的支持，还提供了行级锁和外键的约束，是目前MySQL的默认存储引擎，适用于需要事务和高并发的应用。
- MyISAM引擎是早期的默认存储引擎，支持全文索引，但是不支持事务，也不支持行级锁和外键约束，适用于快速读取且数据量不大的场景。
- Memory就是将数据放在内存中，访问速度快，但数据在数据库服务器重启后会丢失。

### MySQL为什么使用B+树来作索引

B+树是一个B树的变种，提供了高效的数据检索、插入、删除和范围查询性能。

- 单点查询：B树进行单个索引查询时，最快可以在O(1)的时间代价内就查到。从平均时间代价来看，会比B+树稍快一些。但是B树的查询波动会比较大，因为每个节点既存索引又存记录，所以有时候访问到了非叶子节点就可以找到索引，而有时需要访问到叶子节点才能找到索引。B+树的非叶子节点不存放实际的记录数据，仅存放索引，所以数据量相同的情况下，相比存储即存索引又存记录的B树，B+树的非叶子节点可以存放更多的索引，因此B+树可以比B树更「矮胖」，查询底层节点的磁盘I/O次数会更少。

- 插入和删除效率：B+树有大量的冗余节点，删除一个节点的时候，可以直接从叶子节点中删除，甚至可以不动非叶子节点，删除非常快。B+树的插入也是一样，有冗余节点，插入可能存在节点的分裂（如果节点饱和），但是最多只涉及树的一条路径。B树没有冗余节点，删除节点的时候非常复杂，可能涉及复杂的树的变形。

- 范围查询：B+树所有叶子节点间有一个链表进行连接，而B树没有将所有叶子节点用链表串联起来的结构，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘I/O操作，范围查询效率不如B+树。存在大量范围检索的场景，适合使用B+树，比如数据库。而对于大量的单个索引查询的场景，可以考虑B树，比如nosql的MongoDB。

### 说一下索引失效的场景？

索引失效意味着查询操作不能有效利用索引进行数据检索，从而导致性能下降，下面一些场景会发生索引失效。

1. 使用OR条件：当使用OR连接多个条件，并且每个条件用到不同的索引列时，索引可能不会被使用。
2. 使用非等值查询：当使用!=或<>操作符时，索引可能不会被使用，特别是当非等值条件在WHERE子句的开始部分时。
3. 对列进行类型转换：如果在查询中对列进行类型转换，例如将字符列转换为数字或日期，索引可能会失效。
4. 使用LIKE语句：以通配符%开头的LIKE查询会导致索引失效。
5. 函数或表达式：在列上使用函数或表达式作为查询条件，通常会导致索引失效。
6. 表连接中的列类型不匹配：如果在连接操作中涉及的两个表的列类型不匹配，索引可能会失效。例如，一个表的列是整数，另一个表的列是字符，连接时可能会导致索引失效。

### undo log、redo log、binlog有什么用？

- undo log是Innodb存储引擎层生成的日志，实现了事务中的原子性，主要用于事务回滚和MVCC。
- redo log是物理日志，记录了某个数据页做了什么修改，每当执行一个事务就会产生一条或者多条物理日志。
- binlog(归档日志）是Server层生成的日志，主要用于数据备份和主从复制。

### 什么是慢查询？原因是什么？可以怎么优化？

数据库查询的执行时间超过指定的超时时间时，就被称为慢查询。

#### 原因：
- 查询语句比较复杂：查询涉及多个表，包含复杂的连接和子查询，可能导致执行时间较长。
- 查询数据量大：当查询的数据量庞大时，即使查询本身并不复杂，也可能导致较长的执行时间。
- 缺少索引：如果查询的表没有合适的索引，需要遍历整张表才能找到结果，查询速度较慢。
- 数据库设计不合理：数据库表设计庞大，查询时可能需要较多时间。
- 并发冲突：当多个查询同时访问相同的资源时，可能发生并发冲突，导致查询变慢。
- 硬件资源不足：如果MySQL服务器上同时运行了太多的查询，会导致服务器负载过高，从而导致查询变慢。

#### 优化：
1. 运行语句，找到慢查询的sql
2. 查询区分度最高的字段
3. explain：显示mysql如何使用索引来处理select语句以及连接表，可以帮助选择更好的索引、写出更优化的查询语句
4. order by limit形式的sql语句，让排序的表优先查
5. 考虑建立索引原则

---

## Redis

### Redis有什么优缺点？为什么用Redis查询会比较快

#### （1）Redis有什么优缺点？

Redis是一个基于内存的数据库，读写速度非常快，通常被用作缓存、消息队列、分布式锁和键值存储数据库。它支持多种数据结构，如字符串、哈希表、列表、集合、有序集合等，Redis还提供了分布式特性，可以将数据分布在多个节点上，以提高可扩展性和可用性。但是Redis受限于物理内存的大小，不适合存储超大量数据，并且需要大量内存，相比磁盘存储成本更高。

#### （2）为什么Redis查询快

- 基于内存操作：传统的磁盘文件操作相比减少了IO，提高了操作的速度。
- 高效的数据结构：Redis专门设计了STRING、LIST、HASH等高效的数据结构，依赖各种数据结构提升了读写的效率。
- 单线程：单线程操作省去了上下文切换带来的开销和CPU的消耗，同时不存在资源竞争，避免了死锁现象的发生。
- I/O多路复用：采用I/O多路复用机制同时监听多个Socket，根据Socket上的事件来选择对应的事件处理器进行处理。

### Redis的数据类型有那些？

Redis常见的五种数据类型：String（字符串），Hash（哈希），List（列表），Set（集合）及Zset(sorted set：有序集合)。

1. 字符串STRING：存储字符串数据，最基本的数据类型。
2. 哈希表HASH：存储字段和值的映射，用于存储对象。
3. 列表LIST：存储有序的字符串元素列表。
4. 集合SET：存储唯一的字符串元素，无序。
5. 有序集合ZSET：类似于集合，但每个元素都关联一个分数，可以按分数进行排序。

Redis版本更新，又增加了几种数据类型：
- BitMap: 存储位的数据结构，可以用于处理一些位运算操作。
- HyperLogLog：用于基数估算的数据结构，用于统计元素的唯一数量。
- GEO：存储地理位置信息的数据结构。
- Stream：专门为消息队列设计的数据类型。

### Redis是单线程的还是多线程的，为什么？

Redis在其传统的实现中是单线程的(网络请求模块使用单线程进行处理，其他模块仍用多个线程)，这意味着它使用单个线程来处理所有的客户端请求。这样的设计选择有几个关键原因：

1. 简化模型：单线程模型简化了并发控制，避免了复杂的多线程同步问题。
2. 性能优化：由于大多数操作是内存中的，单线程避免了线程间切换和锁竞争的开销。
3. 原子性保证：单线程执行确保了操作的原子性，简化了事务和持久化的实现。
4. 顺序执行：单线程保证了请求的顺序执行。

但是Redis的单线程模型并不意味着它在处理客户端请求时不高效。实际上，由于其操作主要在内存中进行，Redis能够提供极高的吞吐量和低延迟的响应。

此外，Redis 6.0引入了多线程的功能，用来处理网络I/O这部分，充分利用CPU资源，减少网络I/O阻塞带来的性能损耗。

### Redis持久化机制有哪些

- AOF日志：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；
- RDB快照：将某一时刻的内存数据，以二进制的方式写入磁盘；
- 混合持久化方式：Redis 4.0新增的方式，集成了AOF和RBD的优点；

### 缓存雪崩、击穿、穿透和解决办法

1. **缓存雪崩**是指在某个时间点，大量缓存同时失效，导致请求直接访问数据库或其他后端系统，增加了系统负载。
   
   对于缓存雪崩，可以通过合理设置缓存的过期时间，分散缓存失效时间点，或者采用永不过期的策略，再结合定期更新缓存。

2. **缓存击穿**是指一个缓存中不存在但是数据库中存在的数据，当有大量并发请求查询这个缓存不存在的数据时，导致请求直接访问数据库，增加数据库的负载。典型的场景是当一个缓存中的数据过期或被清理，而此时有大量请求访问这个缓存中不存在的数据，导致大量请求直接访问底层存储系统。
   
   对于缓存击穿，可以采用互斥锁（例如分布式锁）或者在查询数据库前先检查缓存是否存在，如果不存在再允许查询数据库，并将查询结果写入缓存。

3. **缓存穿透**是指查询一个在缓存和数据库都不存在的数据，这个数据始终无法被缓存，导致每次请求都直接访问数据库，增加数据库的负载。典型的情况是攻击者可能通过构造不存在的key大量访问缓存，导致对数据库的频繁查询。
   
   对于缓存穿透，可以采用布隆过滤器等手段来过滤掉恶意请求，或者在查询数据库前先进行参数的合法性校验。

### 如何保证数据库和缓存的一致性

#### Cache Aside

- 原理：先从缓存中读取数据，如果没有就再去数据库里面读数据，然后把数据放回缓存中，如果缓存中可以找到数据就直接返回数据；更新数据的时候先把数据持久化到数据库，然后再让缓存失效。
- 问题：假如有两个操作一个更新一个查询，第一个操作先更新数据库，还没来及删除缓存，查询操作可能拿到的就是旧的数据；更新操作马上让缓存失效了，所以后续的查询可以保证数据的一致性；还有的问题就是有一个是读操作没有命中缓存，然后就到数据库中取数据，此时来了一个写操作，写完数据库后，让缓存失效，然后，之前的那个读操作再把老的数据放进去，也会造成脏数据。
- 可行性：出现上述问题的概率其实非常低，需要同时达成读缓存时缓存失效并且有并发写的操作。数据库读写要比缓存慢得多，所以读操作在写操作之前进入数据库，并且在写操作之后更新，概率比较低。

#### Read/Write Through

- 原理：Read/Write Through原理是把更新数据库（Repository）的操作由缓存代理，应用认为后端是一个单一的存储，而存储自己维护自己的缓存。
- Read Through：就是在查询操作中更新缓存，也就是说，当缓存失效的时候，Cache Aside策略是由调用方负责把数据加载入缓存，而Read Through则用缓存服务自己来加载，从而对调用方是透明的。
- Write Through：当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后再由缓存自己更新数据库（这是一个同步操作）。

#### Write Behind

- 原理：在更新数据的时候，只更新缓存，不更新数据库，而缓存会异步地批量更新数据库。这个设计的好处就是让数据的I/O操作非常快，带来的问题是，数据不是强一致性的，而且可能会丢。
- 第二步失效问题：这种可能性极小，缓存删除只是标记一下无效的软删除，可以看作不耗时间。如果会出问题，一般程序在写数据库那里就没有完成：故意在写完数据库后，休眠很长时间再来删除缓存。

---

## Java

### String、StringBuffer、StringBuilder的区别

String, StringBuilder, 和StringBuffer都是Java中用于处理字符串的类，但它们之间有一些重要的区别：

#### 1. 不可变性
- String内部的字符数组使用final修饰，为不可变的字符串类，每当我们对String对象进行改变时，实际上都会创建一个新的String对象，旧的String对象会被JVM回收, 容易触发**gc**，引起系统内存抖动。
- StringBuilder和StringBuilder是可变的。即它们都允许修改字符串，而不会创建新的对象

#### 2. 线程安全
- String：由于String是不可变的，所以是线程安全的。
- StringBuffer中的方法均使用synchronized关键字修饰，线程安全。
- 而StringBuilder线程不安全。

#### 3. 性能
对于复杂的字符串操作（例如多次的拼接，插入，删除），StringBuilder和StringBuilder效率高于String，因为它们是可变的，不需要创建新的对象。

#### 4. 使用场景
- String: 字符串不经常变化的场景中可以使用String类，例如常量的声明、少量的变量运算。
- StringBuilder: 在频繁进行字符串运算（如拼接、替换、和删除等），并且运行在单线程的环境中，则可以考虑使用，如SQL语句的拼装、JSON封装等。
- StringBuffer: 在频繁进行字符串运算（如拼接、替换、删除等），并且运行在多线程环境中，则可以考虑使用StringBuffer，例如XML解析、HTTP参数解析和封装。

### 接口和抽象类的区别

#### 1. 从定义上来说
- 接口是一种抽象类型，它定义了一组方法（方法签名, 包括方法名、参数列表和返回类型）但没有实现任何方法的具体代码。接口中的方法默认是抽象的，且接口中只能包含常量（static final变量）和抽象方法，不能包含成员变量。
- 抽象类是一个类，可以包含抽象方法和具体方法，也可以包含成员变量和常量。抽象类中的抽象方法是没有实现的方法，而具体方法则包含实现代码。抽象类不能直接实例化，通常需要子类继承并实现其中的抽象方法。

#### 2. 继承
- 接口支持多继承，一个类可以实现多个接口。
- Java中不支持多继承，一个类只能继承一个抽象类。如果一个类已经继承了一个抽象类，就不能再继承其他类。

#### 3. 构造器
- 接口不能包含构造器，因为接口不能被实例化。类实现接口时，必须实现接口中定义的所有方法。
- 抽象类可以包含构造器，用于初始化抽象类的实例。当子类实例化时，会调用父类的构造器。

#### 4. 访问修饰符
- 接口中的方法默认是public abstract的。接口中的变量默认是public static final的。
- 抽象类中的抽象方法默认是protected的，具体方法的访问修饰符可以是public、protected或private。

#### 5. 实现限制
- 类可以同时实现多个接口，接口中的方法默认为抽象方法，不包含方法体。实现接口时必须要实现这些方法。
- 一个类只能继承一个抽象类，继承抽象类的子类必须提供抽象类中定义的所有抽象方法的实现。

#### 6. 设计目的
- 接口用于定义规范，强调"行为"或"能力"。
- 抽象类用于代码复用，提供通用的实现或基础功能，并且可以包含方法的具体实现。

### Java常见的异常类有哪些

- Java的异常都是派生于Throwable类的一个实例，所有的异常都是由Throwable继承而来的。
- 异常又分为RuntimeException和其他异常：
  - 由程序错误导致的异常属于RuntimeException
  - 而程序本身没有问题，但由于像I/O错误这类问题导致的异常属于其他异常。

**运行时异常RuntimeException**：
顾名思义，运行时才可能抛出的异常，编译器不会处理此类异常。比如数组索引越界ArrayIndexOutOfBoundsException、使用的对象为空NullPointException、强制类型转换错误NullPointException、除0等等。出现了运行时异常，一般是程序的逻辑有问题，是程序自身的问题而非外部因素。

**其他异常**：
Exception中除了运行时异常之外的，都属于其他异常。也可以称之为编译时异常，这部分异常编译器要求必须处置。这部分异常常常是因为外部运行环境导致，因为程序可能运行在各种环境中，如打开一个不存在的文件，此时抛出FileNotFoundException。编译器要求Java程序必须捕获或声明所有的编译时异常，强制要求程序为可能出现的异常做准备工作。

### 说一说Java面向对象三大特性

Java面向对象编程的三大特性是封装、继承和多态：

1. 封装：封装是将对象的数据（属性）和行为（方法）结合在一起，并隐藏内部的实现细节，只暴露出一个可以被外界访问的接口。通常使用关键字private、protected、public等来定义访问权限，以实现封装。

2. 继承：允许一个类（子类）继承另一个类（父类）的属性和方法的机制。子类可以重用父类的代码，并且可以通过添加新的方法或修改（重写）已有的方法来扩展或改进功能，提高了代码的可重用性和可扩展性。Java支持单继承，一个类只能直接继承一个父类。

3. 多态：多态是指允许不同类的对象对同一消息做出响应，但具体的行为会根据对象的实际类型而有所不同。这通常通过方法重载和重写实现。

### 说一说你对Java多态的理解

1. 当把一个子类对象直接赋给父类引用变量，而运行时调用该引用变量的方法时，其方法行为总是表现出子类方法的行为特征，而不是父类方法的行为特征，这就可能出现：相同类型的变量、调用同一个方法时呈现出多种不同的行为特征，这就是多态。

2. 多态有两种形式：编译时多态（静态多态）和运行时多态（动态多态）。
   - 编译时多态：指在编译阶段，编译器就能够确定调用哪个方法，这是通过方法的重载来实现的。编译器在编译时根据方法的参数数量、类型或顺序来选择调用合适的方法。
   - 运行时多态：在程序运行时，根据实际对象的类型来确定调用的方法，这是通过方法的重写来实现的。运行时多态主要依赖于对象的实际类型，而不是引用类型。

### 重写和重载的区别

Java中的重载和重写是实现多态的两种不同方式。

方法的重载是编译时多态，指的是在同一个类中，可以有多个方法具有相同的名称，但是它们的参数列表不同（参数的类型、个数、顺序），可以有不同的返回类型和访问修饰符，通过静态绑定（编译时决定）实现。

方法的重写是运行时多态，指的是在子类中重新定义父类中已经定义的方法，方法名、参数列表和返回类型都必须相同。重写的方法的访问级别不能低于被重写的父类方法，虚拟机在运行时根据对象的实际类型来确定调用哪个方法。

总结来说，重载关注的是方法的多样性，允许同一个类中存在多个同名方法；而重写关注的是方法的一致性，允许子类提供特定于其自己的行为实现。

### final关键字有什么作用

final就是不可变的意思，可以修饰变量、方法和类。

1. 修饰类：final修饰的类不可被继承，是最终类。
2. 修饰方法：明确禁止该方法在子类中被覆盖的情况下才将方法设置为final
3. 修饰变量：
   - final修饰基本数据类型的变量，其数值一旦在初始化之后便不能更改，称为常量；
   - final修饰引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。虽然不能再指向其他对象，但是它指向的对象的内容是可变的。

### ==和equals的区别

在Java中，==和equals方法用来比较对象，但它们在语义和使用上仍有一定的差别：

1. ==运算符：对于原始数据类型，==比较的是值是否相等，对于引用类型，==比较的是两个引用是否指向内存中的同一位置，即它们是否是同一个对象。

2. equals是一个方法，定义在Object类中，默认情况下，equals()方法比较的是对象的引用，与==类似。但在子类中通常被重写，比如String、Integer等，已经重写了equals()方法以便比较对象的内容是否相等。

3. 一般来说，是使用==比较对象的引用（内存地址），用equals()比较对象的内容。

4. 需要注意的是，在重写equals方法时，应同时重写hashCode方法，以保持equals和hashCode的一致性。

### Java的集合类有哪些，那些是线程安全的，那些是线程不安全的

#### 1. Java中的集合类

Java中的集合类主要由Collection和Map这两个接口派生而出，其中Collection接口又派生出三个子接口，分别是Set、List、Queue。所有的Java集合类，都是Set、List、Queue、Map这四个接口的实现类

- List接口：有序集合，允许重复元素。常见的实现类有ArrayList、LinkedList等。
- Set接口：不允许重复元素的集合。常见的实现类有HashSet、LinkedHashSet、TreeSet等。
- Queue接口: 用于表示队列的数据结构。常见的实现类有LinkedList、PriorityQueue等。
- Map接口: 表示键值对的集合。常见的实现类有HashMap、LinkedHashMap、TreeMap等。

#### 2. 线程不安全的集合类
- ArrayList、LinkedList、HashSet、HashMap：这些集合类是非线程安全的。在多线程环境中，如果没有适当的同步措施，对这些集合的并发操作可能导致不确定的结果。
- TreeMap、TreeSet：虽然TreeMap和TreeSet是有序的集合，但它们也是非线程安全的。

#### 3. 线程安全的集合类
- Vector：类似于ArrayList，它的方法都是同步的，因此是线程安全的。然而，它相对较重，不够灵活，现在通常建议使用ArrayList。
- HashTable：类似于HashMap，但它是线程安全的，通过同步整个对象实现。但它的使用已经不太推荐，通常建议使用HashMap。
- ConcurrentHashMap：提供更好的并发性能，通过锁分离技术实现线程安全。
- Collections.synchronizedList、Collections.synchronizedSet、Collections.synchronizedMap：这些方法可以将非线程安全的集合包装成线程安全的集合。

### ArrayList和Array有什么区别？ArrayList和LinkedList的区别是什么？

#### 1. ArrayList vs Array：
- ArrayList是动态数组的实现，而Array是固定长度的数组。
- ArrayList提供了更多的功能，比如自动扩容、增加和删除元素等，Array则没有这些功能。
- Array可以直接存储基本类型数据，也可以存储对象。ArrayList中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如Integer、Double等）
- 在随机访问时，Array由于其连续内存存储，性能通常优于ArrayList。

#### 2. ArrayList vs LinkedList：
- ArrayList基于动态数组，LinkedList基于双向链表。
- 随机访问：ArrayList在随机访问时性能更好，而LinkedList访问元素时效率较低，因为需要从头开始或从尾开始通过链接遍历，时间复杂度为O(n)。
- 删除/添加元素：在ArrayList末尾添加元素通常很快，但在ArrayList中间或开始插入或删除元素时，可能需要移动后续元素，时间复杂度为O(n)。而LinkedList添加和删除元素时性能更佳，只需改变节点的引用。
- 扩容：当容量不足以容纳更多元素时，ArrayList会扩容，这个过程涉及创建新数组和复制旧数组的内容，有一定的开销。
- 使用场景：选择ArrayList或者LinkedList通常取决于你的Java应用是否需要频繁的随机访问操作，还是更多的插入和删除操作。

总结来说，ArrayList和Array的主要区别在于动态大小和功能，而ArrayList和LinkedList的主要区别在于底层数据结构和它们对元素操作的性能特点。选择使用哪一个取决于具体的应用场景和性能需求。

### ArrayList的扩容机制

1. ArrayList扩容的本质就是计算出新的扩容数组的size后实例化，并将原有数组内容复制到新数组中去。（不是原数组，而是新数组然后给予数组对象地址）。

2. 当创建一个ArrayList对象时，它会分配一定的初始容量，通常为10。这是为了节省内存，因为并不是所有的ArrayList都需要大量的空间。

3. 当ArrayList中的元素数量达到当前容量时，ArrayList会自动增加其容量。ArrayList扩容的计算是在一个grow()方法里面，grow方法先尝试将数组扩大为原数组的1.5倍。（新容量=旧容量右移一位（相当于除于2）在加上旧容量）

4. 若新的容量满足需求，会调用一个Arrays.copyof方法，将所有的元素从旧数组复制到新数组中，这个方法是真正实现扩容的步骤。如果扩容后的新容量还是不满足需求，那新容量大小为当前所需的容量加1。

### Java中的HashMap了解吗？HashMap的底层实现是什么？

#### 1. 底层实现

在JDK 1.8之前，HashMap由数组和链表组成，当发生哈希冲突时，多个元素会以链表的形式存储在同一个数组位置。JDK 1.8开始引入了红黑树，当链表长度超过一定阈值（TREEIFY_THRESHOLD，默认为8）时，链表会转换成红黑树，以提高搜索效率。

#### 2. 为什么链表大小超过8会自动转为红黑树，小于6时重新变成链表

根据泊松分布，在负载因子默认为0.75的时候，单个hash槽内元素个数为8的概率小于百万分之一，所以将7作为一个分水岭，等于7的时候不转换，大于等于8的时候才转换成红黑树，小于等于6的时候转化为链表。

#### 3. 为什么要引入红黑树，而不是其他树？

是因为红黑树具有以下几点性质：
- 不追求绝对的平衡，插入或删除节点时，允许有一定的局部不平衡，相较于AVL树的绝对自平衡，减少了很多性能开销；
- 红黑树是一种自平衡的二叉搜索树，因此插入和删除操作的时间复杂度都是O(log n)

#### 4. HashMap读和写的时间复杂度是多少？

- 读：
  - 最佳情况下：直接通过数组下标访问数据，O(1)；
  - 最坏情况下：发生哈希冲突，链表为O(n)，红黑树为O(log n)。
- 写：O(1)，但是如果所有元素都在一个桶内，则每次插入需要O(n)。

### 解决Hash冲突的方法有哪些？HashMap是如何解决hash冲突的

解决哈希冲突的方法主要有以下两种：

1. 链地址法：在数组的每个位置维护一个链表。当发生冲突时，新的元素会被添加到链表的尾部。
2. 开放寻址法：当发生冲突时，根据某种探测算法在哈希表中寻找下一个空闲位置来存储元素。

Java中的HashMap使用链地址法解决hash冲突。

### HashMap的put方法流程

1. 判断键值对数组是否为空或为null，否则执行resize()进行扩容；
2. 根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向步骤6，如果table[i]不为空，转向步骤3；
3. 判断数组的首个元素是否和key一样，如果相同直接覆盖value，否则转向4，这里的相同指的是hashCode以及equals；
4. 判断table[i]是否为treeNode，即table[i]是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向5；
5. 遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；
6. 插入成功后，判断实际存在的键值对数量size是否超多了最大容量，如果超过，进行扩容。

### HashMap的扩容机制

#### Java1.7扩容机制
- 生成新数组；
- 遍历老数组中的每个位置上的链表上的每个元素；
- 获取每个元素的key，并基于新数组长度，计算出每个元素在新数组中的下标；
- 将元素添加到新数组中去；
- 所有元素转移完之后，将新数组赋值给HashMap对象的table属性。

#### JDK1.8版本扩容
- 生成新数组；
- 遍历老数组中的每个位置上的链表或红黑树；
- 如果是链表，则直接将链表中的每个元素重新计算下标，并添加到新数组中去；
- 如果是红黑树，则先遍历红黑树，先计算出红黑树中每个元素对应在新数组中的下标位置；
  - 统计每个下标位置的元素个数；
  - 如果该位置下的元素个数超过了8，则生成一个新的红黑树，并将根节点添加到新数组的对应位置；
  - 如果该位置下的元素个数没有超过8，那么则生成一个链表，并将链表的头节点添加到新数组的对应位置；
- 所有元素转移完了之后，将新数组赋值给HashMap对象的table属性。

### HashMap为什么是线程不安全的? 如何实现线程安全

#### （1）为什么是线程不安全的

主要原因是它的操作不是原子的，即在多个线程同时进行读写操作时，可能会导致数据不一致性或抛出异常。

1. 并发修改：当一个线程进行写操作（插入、删除等）时，另一个线程进行读操作，可能会导致读取到不一致的数据，甚至抛出ConcurrentModificationException异常。
2. 非原子性操作：HashMap的一些操作不是原子的，例如，检查是否存在某个键、获取某个键对应的值等，这样在多线程环境中可能发生竞态条件。

#### （2）如何实现线程安全

为了实现线程安全的HashMap，有以下几种方式：
- 使用Collections.synchronizedMap()方法：可以通过Collections.synchronizedMap()方法创建一个线程安全的HashMap，该方法返回一个同步的Map包装器，使得所有对Map的操作都是同步的。
- 使用ConcurrentHashMap：ConcurrentHashMap是专门设计用于多线程环境的哈希表实现。它使用分段锁机制，允许多个线程同时进行读操作，提高并发性能。
- 使用锁机制：可以在自定义的HashMap操作中使用显式的锁（例如ReentrantLock）来保证线程安全。

### concurrentHashMap如何保证线程安全

1. ConcurrentHashMap在JDK 1.7中使用的数组加链表的结构，其中数组分为两类，大数组Segment和小数组HashEntry，ConcurrentHashMap的线程安全是建立在Segment加ReentrantLock重入锁来保证。

2. ConcurrentHashMap在JDK1.8中使用的是数组加链表加红黑树的方式实现，它是通过CAS或者synchronized来保证线程安全的，并且缩小了锁的粒度，查询性能也更高。

### HashSet 和 HashMap 的区别

#### 内部实现：
- HashMap 使用键值对的方式存储数据，通过哈希表实现。
- HashSet 实际上是基于 HashMap 实现的，它只使用了 HashMap 的键部分，将值部分设置为一个固定的常量。

#### 元素类型：
- HashMap 存储键值对，可以通过键获取对应的值。
- HashSet 存储单一元素，只能通过元素本身进行操作。

#### 允许 null：
- HashMap 允许键和值都为 null。
- HashSet 允许存储一个 null 元素。

#### 迭代方式：
- HashMap 的迭代是通过迭代器或增强型 for 循环遍历键值对。
- HashSet 的迭代是通过迭代器或增强型 for 循环遍历元素。

#### 关联关系：
- HashMap 中的键与值是一一对应的关系。
- HashSet 中的元素没有关联的值，只有元素本身。

#### 性能影响：
- HashMap 的性能受到键的哈希分布和哈希冲突的影响。
- HashSet 的性能也受到元素的哈希分布和哈希冲突的影响，但由于它只存储键，通常比 HashMap 的性能稍好。

---

### HashMap 和 HashTable 的区别

#### 同步
- Hashtable 是同步的，即它的方法是线程安全的。这是通过在每个方法上添加同步关键字来实现的，但这也可能导致性能下降。
- HashMap 不是同步的，因此它不保证在多线程环境中的线程安全性。如果需要同步，可以使用 Collections.synchronizedMap() 方法来创建一个同步的 HashMap。

#### 性能
- 由于 Hashtable 是同步的，它在多线程环境中的性能可能较差。
- HashMap 在单线程环境中可能比 Hashtable 更快，因为它没有同步开销。

#### 空值
- Hashtable 不允许键或值为 null。
- HashMap 允许键和值都为 null。

#### 继承关系
- Hashtable 是 Dictionary 类的子类，而 HashMap 是 AbstractMap 类的子类，实现了 Map 接口。

#### 迭代器
- Hashtable 的迭代器是通过 Enumerator 实现的。
- HashMap 的迭代器是通过 Iterator 实现的。

#### 初始容量和加载因子
- Hashtable 的初始容量和加载因子是固定的。
- HashMap 允许通过构造方法设置初始容量和加载因子，以便更好地调整性能。

---

### HashMap和ConcurrentHashMap的区别

#### 线程安全性：
- HashMap 不是线程安全的。在多线程环境中，如果同时进行读写操作，可能会导致数据不一致或抛出异常。
- ConcurrentHashMap 是线程安全的，它使用了分段锁（Segment Locking）的机制，将整个数据结构分成多个段（Segment），每个段都有自己的锁。这样，不同的线程可以同时访问不同的段，提高并发性能。

#### 同步机制：
- HashMap 在实现上没有明确的同步机制，需要在外部进行同步，例如通过使用 Collections.synchronizedMap() 方法。
- ConcurrentHashMap 内部使用了一种更细粒度的锁机制，因此在多线程环境中具有更好的性能。

#### 迭代时是否需要加锁：
- 在 HashMap 中，如果在迭代过程中有其他线程对其进行修改，可能抛出 ConcurrentModificationException 异常。
- ConcurrentHashMap 允许在迭代时进行并发的插入和删除操作，而不会抛出异常。但是，它并不保证迭代器的顺序，因为不同的段可能会以不同的顺序完成操作。

#### 初始化容量和负载因子：
- HashMap 可以通过构造方法设置初始容量和负载因子。
- ConcurrentHashMap 在Java 8及之后版本中引入了ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)构造方法，允许设置初始容量、负载因子和并发级别。

#### 性能：
- 在低并发情况下，HashMap 的性能可能会比 ConcurrentHashMap 稍好，因为 ConcurrentHashMap 需要维护额外的并发控制。
- 在高并发情况下，ConcurrentHashMap 的性能通常更好，因为它能够更有效地支持并发访问。

**总的来说，** 如果需要在多线程环境中使用哈希表，而且需要高性能的并发访问，通常会选择使用 ConcurrentHashMap。如果在单线程环境中使用，或者能够手动进行外部同步管理，那么 HashMap 可能是更简单的选择。

---

### Java创建线程的方式

在 Java 中，创建线程有四种方式，分别是 **继承Thread类，实现Runnable接口，使用Callable和Future, 使用线程池**。

1. **继承Thread类：** 通过创建Thread类的子类，并重写其run方法来定义线程执行的任务。

2. **实现Runnable接口：** 创建一个实现了Runnable接口的类，并实现其run方法。然后创建该类的实例，并将其作为参数传递给Thread 对象。

3. **使用Callable和Future接口：** 创建一个实现了Callable接口的类，并实现其call方法，该方法可以返回结果并抛出异常。使用ExecutorService来管理线程池，并提交Callable任务获取Future对象，以便在未来某个时刻获取Callable任务的计算结果。

4. **使用线程池：** 通过使用Executors类创建线程池，并通过线程池来管理线程的创建和复用。

---

### 线程 start 和 run 的区别

在Java多线程中，run 方法和 start 方法的区别在于：

1. **run 方法**是线程的执行体，包含线程要执行的代码，当直接调用 run 方法时，它会在当前线程的上下文中执行，而不会创建新的线程。

2. **start 方法**用于启动一个新的线程，并在新线程中执行 run 方法的代码。调用 start 方法会为线程分配系统资源，并将线程置于就绪状态，当调度器选择该线程时，会执行 run 方法中的代码。

**因此，** 虽然可以直接调用 run 方法，但这并不会创建一个新的线程，而是在当前线程中执行 run 方法的代码。如果需要实现多线程执行，则应该调用 start 方法来启动新线程。

---

### 你知道Java中有哪些锁吗

1. **公平锁/非公平锁：** 公平锁指多个线程按照申请锁的顺序来获取锁，非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。 对于 Java ReentrantLock 而言，默认是非公平锁，对于 Synchronized 而言，也是一种非公平锁。

2. **可重入锁（递归锁）：** 在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。对于 Java ReentrantLock 而言，是可重入锁，对于 Synchronized 而言，也是一个可重入锁。

3. **独享锁/共享锁：** 独享锁是指该锁一次只能被一个线程所持有。共享锁是指该锁可被多个线程所持有。对于 Java ReentrantLock 而言，其是独享锁。但是对于Lock的另一个实现类 ReadWriteLock，其读锁是共享锁，其写锁是独享锁。 对于 Synchronized 而言，当然是独享锁。

4. **互斥锁/读写锁：** 上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。 互斥锁在Java中的具体实现就是 ReentrantLock。读写锁在Java中的具体实现就是 ReadWriteLock

5. **乐观锁/悲观锁：** 乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。 悲观锁在Java中的使用，就是利用各种锁。 乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。

6. **分段锁：** 分段锁其实是一种锁的设计，并不是具体的一种锁，对于 ConcurrentHashMap 而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。

7. **偏向锁/轻量级锁/重量级锁：** 这三种锁是指锁的状态，并且是针对 Synchronized。在Java 5通过引入锁升级的机制来实现高效 Synchronized 。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。

8. **自旋锁：** 在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。

---

### 说说你对 synchronized的理解

synchronized是Java中的一个关键字，用于实现同步和线程安全。

- 当一个方法或代码块被 synchronized 修饰时，它将成为一个临界区，同一时刻只能由一个线程访问。其他线程必须等待当前线程退出临界区才能进入。确保多个线程在访问共享资源时不会产生冲突

- synchronized 可以应用于方法或代码块。当它应用于方法时，整个方法被锁定；当它应用于代码块时，只有该代码块被锁定。这样做的好处是，可以选择性地锁定对象的一部分，而不是整个方法。

- synchronized 实现的机理依赖于软件层面上的JVM，因此其性能会随着Java版本的不断升级而提高。 到了 Java1.6，synchronized 进行了很多的优化，有适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等，效率有了本质上的提高。在之后推出的 Java1.7 与 1.8 中，均对该关键字的实现机理做了优化。 需要说明的是，当线程通过 synchronized 等待锁时是不能被 Thread.interrupt() 中断的，因此程序设计时必须检查确保合理，否则可能会造成线程死锁的尴尬境地。

- 最后，尽管 Java 实现的锁机制有很多种，并且有些锁机制性能也比 synchronized 高，但还是强烈推荐在 多线程应用程序中使用该关键字，因为实现方便，后续工作由 JVM 来完成，可靠性高。只有在确定锁机 制是当前多线程程序的性能瓶颈时，才考虑使用其他机制，如 ReentrantLock 等。

---

### synchronized和Lock的区别是什么

synchronized和Lock都是Java中用于实现线程同步的手段，synchronized是Java的关键字，基于JVM的内置锁实现，可以用于修饰方法或代码块，使用起来比较简单直接。而Lock是一个接口，是Java提供的显式锁机制，需要手动获取和释放锁，通过实现类（如ReentrantLock）来创建锁对象，然后主动调用锁的获取和释放方法。

#### 特性
- **synchronized：** 灵活性相对较低，只能用于方法或代码块。而且synchronized方法一旦开始执行，即使线程被阻塞，也不能中断。没有超时机制，一旦获取不到锁就会一直等待，也没有公平性的概念，线程调度由JVM控制。

- **lock：** 提供了更多的灵活性，例如可以尝试获取锁，如果锁已被其他线程持有，可以选择等待或者中断等待。提供了超时获取锁的能力，可以在指定时间内尝试获取锁，也可以设置为公平锁，按照请求锁的顺序来获取锁。

#### 等待与通知：
- **synchronized：** 与 wait() 和 notify()/notifyAll() 方法一起使用，用于线程的等待和通知。

- **lock：** 可以与 Condition 接口结合，实现更细粒度的线程等待和通知机制。

#### 使用场景：
总结来说，synchronized使用简单，适合锁的粒度较小、竞争不激烈、实现简单的场景。而Lock提供了更多的灵活性和控制能力，适用于需要更复杂同步控制的场景。

---

### synchronized和ReentrantLock的区别是什么

synchronized和ReentrantLock都是Java中用于实现线程同步的手段，synchronized是Java的关键字，基于JVM的内置锁实现，可以用于修饰方法或代码块，使用起来比较简单直接。而ReentrantLock是java.util.concurrent.locks包中的一个锁实现，需要显式创建，并通过调用lock()和unlock()方法来管理锁的获取和释放。

#### 特性
- **synchronized：** 灵活性相对较低，只能用于方法或代码块。而且synchronized方法一旦开始执行，即使线程被阻塞，也不能中断。没有超时机制，一旦获取不到锁就会一直等待，也没有公平性的概念，线程调度由JVM控制。

- **ReentrantLock：** 支持中断操作，可以在等待锁的过程中响应中断, 提供了尝试获取锁的超时机制，可以通过tryLock()方法设置超时时间。可以设置为公平锁，按照请求的顺序来获取锁，提供了isLocked()、isFair()等方法，可以检查锁的状态。

#### 条件变量：
- **synchronized**可以通过wait()、notify()、notifyAll()与对象的监视器方法配合使用来实现条件变量。

- **ReentrantLock**可以通过Condition新API实现更灵活的条件变量控制。

#### 锁绑定多个条件：
- **synchronized**与单个条件关联，需要使用多个方法调用来实现复杂的条件判断。

- **ReentrantLock**可以与多个Condition对象关联，每个对象可以有不同的等待和唤醒逻辑。

#### 使用场景：
总结来说，synchronized适合简单的同步需求，而ReentrantLock提供了更丰富的控制能力和灵活性，适用于需要复杂同步控制的场景。

---

### volatile 关键字的作用有那些？

volatile 通常被比喻成"轻量级的 synchronized "，它不需要获取和释放锁，是Java并发编程中比较重要的一个关键字。 和 synchronized 不同， volatile 是一个变量修饰符，只能用来修饰变量。无法修饰方法及代码块等。

volatile关键字在Java中主要用于保证变量的内存可见性和禁止指令重排。

- **保证可见性：** 确保当一个线程修改了一个volatile变量时，其他线程能够立即看到这个改变。
    - 当对非 volatile 变量进行读写的时候，每个线程先从主内存拷贝变量到 CPU 缓存中，如果计算机有多个 CPU，每个线程可能在不同的 CPU 上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。
    - volatile 变量不会被缓存在寄存器或者对其他处理器不可见的地方，保证了每次读写变量都从主内存中读，跳过 CPU cache 这一步。当一个线程修改了这个变量的值，新值对于其他线程是立即得知的。

- **禁止指令重排：** volatile变量的写操作在JVM执行时不会发生指令重排，确保写入操作在读取操作之前完成。
    - 指令重排序是 JVM 为了优化指令、提高程序运行效率，在不影响单线程程序执行结果的前提下，尽可能地提高并行度，包括编译器重排序和运行时重排序;
    - volatile 变量禁止指令重排序。针对 volatile 修饰的变量，在读写操作指令前后会插入内存屏障，指令重排序时不能把后面的指令重排序到内存屏障。

- 虽然volatile可以确保可见性，但它不保证复合操作的原子性。

---

### volatile 与synchronized 的对比

volatile和synchronized都是Java中用于多线程同步的工具，在用途、原子性、互斥性、性能和使用场景上有一定的区别。

#### 机制和用途
- **synchronized：** 用于提供线程间的同步机制。当一个线程进入一个由 synchronized 修饰的代码块或方法时，它会获取一个监视器锁，这保证了同一时间只有一个线程可以执行这段代码。其主要用途是确保数据的一致性和线程安全性。

- **volatile：** 用于修饰变量。volatile 的主要作用是确保变量的可见性，即当一个线程修改了一个 volatile 变量的值，其他线程能够立即看到这个修改。此外，它还可以防止指令重排序。但是，volatile 并不能保证复合操作的原子性。

- **总结：** volatile 关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。

#### 原子性
- **synchronized：** 可以保证被其修饰的代码块的原子性，即这段代码在执行过程中不会被其他线程打断。

- **volatile：** 只能保证单个读写操作的原子性，对于复合操作（如自增、自减等）则无法保证原子性。

#### 性能
volatile 通常比 synchronized 更轻量级，所以 volatile 性能肯定比 synchronized 关键字要好; 因为它不涉及锁的获取和释放。但是，这也意味着它提供的同步级别较低。

#### 互斥性：
- **synchronized：** 提供了互斥性，即同一时间只有一个线程可以执行被其修饰的代码块或方法。

- **volatile：** 不提供互斥性，只是确保变量的可见性。

#### 使用场景
- volatile适用于简单的内存可见性要求
- 而synchronized可以通过ReentrantLock等扩展为更灵活的锁机制，适用于需要保证原子性、可见性和互斥的复杂同步场景。

---

### 为什么要有线程池？

- **资源管理：** 在多线程应用中，每个线程都需要占用内存和CPU资源，如果不加限制地创建线程，会导致系统资源耗尽，可能引发系统崩溃。线程池通过限制并控制线程的数量，帮助避免这个问题。

- **提高性能：** 通过重用已存在的线程，线程池可以减少创建和销毁线程的开销。

- **任务排队：** 线程池通过任务队列和工作线程的配合，合理分配任务，确保任务按照一定的顺序执行，避免线程竞争和冲突

- **统一管理：** 线程池提供了统一的线程管理方式，可以对线程进行监控、调度和管理。

**总结：** 采用多线程编程的时候如果线程过多会造成系统资源的大量占用，降低系统效率。如果有些线程存活的时间很短但是又不得不创建很多这种线程也会造成资源的浪费。线程池的作用就是创造并且管理一部分线程，当系统需要处理任务时直接将任务添加到线程池的任务队列中，由线程池决定由哪个空闲且存活线程来处理，当线程池中线程不够时会适当创建一部分线程，线程冗余时会销毁一部分线程。这样提高线程的利用率，降低系统资源的消耗。

---

### 说一说线程池有哪些常用参数

- **corePoolSize核心线程数：** 线程池中长期存活的线程数。

- **maximumPoolSize最大线程数：** 线程池允许创建的最大线程数量，当线程池的任务队列满了之后，可以创建的最大线程数。

- **keepAliveTime空闲线程存活时间：** 当线程数大于corePoolSize时，多余的空闲线程能等待新任务的最长时间。

- **TimeUnit:** 与keepAliveTime一起使用，指定keepAliveTime的时间单位，如秒、分钟等。

- **workQueue线程池任务队列:** 线程池存放任务的队列，用来存储线程池的所有待执行任务。

- **ThreadFactory创建线程的工厂:** 线程池创建线程时调用的工厂方法，通过此方法可以设置线程的优先级、线程命名规则以及线程类型（用户线程还是守护线程）等。

- **RejectedExecutionHandler拒绝策略:** 当线程池的任务超出线程池队列可以存储的最大值之后，执行的策略。

---

### BIO、NIO、AIO 的区别

BIO、AIO和NIO是Java中不同的I/O模型，它们在处理输入输出操作时有不同的特点。

- **BIO:** 阻塞式的I/O模型。当一个线程执行I/O操作时，如果数据还没准备好，这个线程会被阻塞，直到数据到达。适合连接数较少且固定的场景，但扩展性较差。

- **NIO:** 非阻塞的I/O模型。NIO使用缓冲区和通道来处理数据，提高了I/O操作的效率。支持面向缓冲区的读写操作，可以处理大量并发的连接。

- **AIO:** 异步I/O模型，从Java 7开始引入。在AIO中，I/O操作被发起后，线程可以继续执行其他任务，一旦I/O操作完成，操作系统会通知线程。适合需要处理大量并发I/O操作，且希望避免I/O操作阻塞线程的场景。

#### 使用场景：
- BIO适合低并发、连接数较少的应用。
- NIO适合高并发、需要处理大量连接的应用。
- AIO适合需要高性能、异步处理I/O操作的场景。

---

### Java内存区域

Java的内存区域主要分为以下几个部分：

1. **程序计数器：** 程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。在多线程环境下，每个线程都有自己独立的程序计数器。当线程执行Java方法时，程序计数器记录的是正在执行的虚拟机字节码指令的地址。

2. **Java虚拟机栈：** 每个Java线程都有一个私有的Java虚拟机栈，与线程同时创建。每个方法在执行时都会创建一个栈帧，用于存储局部变量、操作数栈、动态链接、方法出口等信息。栈帧在方法调用时入栈，方法返回时出栈。

3. **本地方法栈：** 本地方法栈与Java虚拟机栈类似，但它为本地方法服务。本地方法是用其他编程语言（如C/C++）编写的，通过JNI与Java代码进行交互。

4. **堆：** Java堆是Java虚拟机中最大的一块内存区域，用于存储对象实例。所有的对象实例和数组都在堆上分配内存。堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。堆可以分为新生代和老年代等不同的区域，其中新生代又包括Eden空间、Survivor空间（From和To）。

5. **方法区：** 方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。在HotSpot虚拟机中，方法区也被称为永久代，但在较新的JVM版本中，永久代被元空间所取代。

6. **运行时常量池：** 是方法区的一部分，用于存储编译期生成的类、方法和常量等信息。

7. **字符串常量池:** 字符串常量池是 JVM 为了提升性能和减少内存消耗针对字符串专门开辟的一块区域，主要目的是为了避免字符串的重复创建。

8. **直接内存：** 不是Java虚拟机运行时数据区的一部分，但Java可以通过NIO操作直接内存，提高IO性能。

---

### 介绍一下什么是强引用、软引用、弱引用、虚引用

这四种引用决定了对象的生命周期以及垃圾收集器如何收集垃圾。

1. **强引用：** 最常见的引用类型。如果一个对象具有强引用，那么垃圾收集器绝不会回收它。

2. **软引用：** 软引用用于描述一些还有用但非必需的对象。如果一个对象只有软引用指向它，那么在系统内存不足时，垃圾回收器会尝试回收这些对象。软引用通常用于实现内存敏感的缓存，可以在内存不足时释放缓存中的对象。

3. **弱引用：** 弱引用比软引用的生命周期更短暂。如果一个对象只有弱引用指向它，在进行下一次垃圾回收时，不论系统内存是否充足，这些对象都会被回收。弱引用通常用于实现对象缓存，但不希望缓存的对象影响垃圾回收的情况。

4. **虚引用：** 虚引用是Java中最弱的引用类型。如果一个对象只有虚引用指向它，那么无论何时都可能被垃圾回收器回收，但在对象被回收之前，虚引用会被放入一个队列中，供程序员进行处理。虚引用主要用于跟踪对象被垃圾回收的时机，进行一些必要的清理或记录。

---

### 有哪些垃圾回收算法

1. **标记-清除算法**

标记清除算法将垃圾回收分为两个阶段:标记阶段和清除阶段。在标记阶段首先通过根节点(GC Roots)，标记所有从根节点开始的对象，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。

**适用场合:**
- 存活对象较多的情况下比较高效
- 适用于年老代(即旧生代)

2. **复制算法**

从根集合节点进行扫描，标记出所有的存活对象，并将这些存活的对象复制到一块儿新的内存上去，之后将原来的那一块儿内存全部回收掉。现在的商业虚拟机都采用这种收集算法来回收新生代。

**适用场合:**
- 存活对象较少的情况下比较高效
- 扫描了整个空间一次(标记存活对象并复制移动)
- 适用于年轻代(即新生代):基本上98%的对象是"朝生夕死"的，存活下来的会很少

**缺点：**
- 需要一块儿空的内存空间
- 需要复制移动对象
- 复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活的对象较多，复制的成本也将很高。

3. **标记整理**

标记-压缩算法是一种老年代的回收算法，它在标记-清除算法的基础上做了一些优化。 首先也需要从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。

4. **分代收集算法**

分代收集算法就是目前虚拟机使用的回收算法，它解决了标记整理不适用于老年代的问题，将内存分为各个年代。一般情况下将堆区划分为老年代(Tenured Generation)和新生代(Young Generation)，在堆区之外还有一个代就是永久代(Permanet Generation)。 在不同年代使用不同的算法，从而使用最合适的算法，新生代存活率低，可以使用复制算法。而老年代对象存活率搞，没有额外空间对它进行分配担保，所以只能使用标记清除或者标记整理算法。

---

### 有哪些垃圾回收器

#### 新生代垃圾收集器

1. **Serial 收集器（复制算法）** 是新生代单线程收集器，优点是简单高效，算是最基本、发展历史最悠久的收集器。它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集完成。

2. **ParNew 收集器（复制算法）** 是新生代并行收集器，其实就是 Serial 收集器的多线程版本。

3. **Parallel Scavenge 收集器** 是新生代并行收集器，追求高吞吐量，高效利用 CPU。

#### 老年代垃圾收集器

1. **Serial Old** 是Serial收集器的老年代版本，它同样是一个单线程(串行)收集器，使用标记整理算法。这个收集器的主要意义也是在于给Client模式下的虚拟机使用。

2. **Parallel Old** 是Parallel Scavenge收集器的老年代版本，使用多线程和"标记-整理"算法。这个收集器在 1.6中才开始提供。

3. **CMS 收集器** 是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务器的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。

**CMS收集器是基于"标记-清除"算法实现的，** 它的运作过程相对前面几种收集器来说更复杂一些，整个过程分为4个步骤:
- 初始标记
- 并发标记
- 重新标记
- 并发清除

#### 新生代和老年代垃圾收集器

1. **G1收集器-标记整理算法：** JDK1.7后全新的回收器, 用于取代CMS收集器。

**G1 收集器的优势:**
- 独特的分代垃圾回收器,分代GC: 分代收集器, 同时兼顾年轻代和老年代
- 使用分区算法, 不要求eden, 年轻代或老年代的空间都连续
- 并行性: 回收期间, 可由多个线程同时工作, 有效利用多核cpu资源
- 空间整理: 回收过程中, 会进行适当对象移动, 减少空间碎片
- 可预见性: G1可选取部分区域进行回收, 可以缩小回收范围, 减少全局停顿

**G1收集器的阶段分以下几个步骤:**
- 初始标记(它标记了从GC Root开始直接可达的对象)
- 并发标记(从GC Roots开始对堆中对象进行可达性分析，找出存活对象)
- 最终标记(标记那些在并发标记阶段发生变化的对象，将被回收)
- 筛选回收(首先对各个Regin的回收价值和成本进行排序，根据用户所期待的GC停顿时间指定回收计划，回收一部分Region)

---

### 类加载机制介绍一下

类加载机制是Java虚拟机运行Java程序时负责将类加载到内存中的过程。它包括以下几个步骤：

1. **加载：** 在此阶段，类加载器负责查找类的字节码文件，并将其加载到内存中。字节码可以来自文件系统、网络等位置。加载阶段不会执行类中的静态初始化代码。

2. **连接：** 连接阶段包括三个子阶段：
    - **验证：** 确保加载的类文件格式正确，并且不包含不安全的构造。
    - **准备：** 在内存中为类的静态变量分配内存空间，并设置默认初始值。这些变量在此阶段被初始化为默认值，比如数值类型为0，引用类型为null。
    - **解析：** 将类、接口、字段和方法的符号引用解析为直接引用，即内存地址。这一步骤可能包括将常量池中的符号引用解析为直接引用。

3. **初始化：** 在此阶段，执行类的静态初始化代码，包括静态字段的赋值和静态代码块的执行。静态初始化在类的首次使用时进行，可以是创建实例、访问静态字段或调用静态方法。

---

### 双亲委派机制是什么?

双亲委派机制是Java类加载器中的一种设计模式，用于确定类的加载方式和顺序。这个机制确保了Java核心库的安全性和一致性。该机制的核心思想是：如果一个类加载器收到了类加载请求，默认先将该请求委托给其父类加载器处理。只有当父级加载器无法加载该类时，才会尝试自行加载。

双亲委派机制能够提高安全性，防止核心库的类被篡改。因为所有的类最终都会通过顶层的启动类加载器进行加载。另外由于类加载器直接从父类加载器那里加载类，也避免了类的重复加载。

---

### 说一说你对Spring AOP的了解

面向切面编程，可以说是面向对象编程的补充和完善。OOP 引入封装、继承、多态等概念来建立一种对象层次结构。不过 OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。AOP 技术恰恰相反，它利用一种称为"横切"的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为切面。所谓"切面"，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。

Spring 中AOP 代理由 Spring 的IOC 容器负责生成、管理，其依赖关系也由 IOC 容器负责管理。因此，AOP 代理可以直接使用容器中的其它 bean 实例作为目标，这种关系可由 IOC 容器的依赖注入提供。Spring 创建代理的规则为:
- 默认使用 JDK 动态代理来创建AOP代理，这样就可以为任何接口实例创建代理了
- 当需要代理类，而不是代理接口的时候，Spring 会切换为使用 CGLIB代理 ，也可强制使用 CGLIB

**AOP 编程其实是很简单的事情，** 纵观 AOP 编程，程序员只需要参与三个部分:
- 定义普通业务组件
- 定义切入点，一个切入点可能横切多个业务组件
- 定义增强处理，增强处理就是在 AOP 框架为普通业务组件织入的处理动作

所以进行 AOP 编程的关键就是定义切入点和定义增强处理，一旦定义了合适的切入点和增强处理，AOP 框架将自动生成 AOP 代理，即: 代理对象的方法=增强处理+被代理对象的方法。

---

### 说一说你对 Spring中IOC的理解

#### 什么是 IOC

Spring的IOC，也就是控制反转，它的核心思想是让对象的创建和依赖关系由容器来控制，不是我们自己new出来的，这样各个组件之间就能保持松散的耦合。

这里的容器实际上就是个Map, Map 中存放的是各种对象。通过DI依赖注入，Spring容器可以在运行时动态地将依赖注入到需要它们的对象中，而不是对象自己去寻找或创建依赖。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。举例来说，在实际项目中一个 Service 类可能有几百甚至上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了。

#### 如何配置

Spring 时代我们一般通过 XML 文件来配置，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。使用配置可以告诉Spring容器如何创建对象、如何管理对象的生命周期。

**总结来说，** Spring的IOC容器是一个中央化的、负责管理应用中所有对象生命周期的强大工具

---

### Bean的作用域

在 Spring 中，那些组成应用程序的主体及由 Spring IOC 容器所管理的对象，被称之为 Bean。而 Bean 的作用域定义了在应用程序中创建的 Bean 实例的生命周期和可见范围，主要有以下几种。

1. **单例：** 这是默认的作用域，当一个 Bean 的作用域为 Singleton，那么 Spring IoC 容器中只会存在一个共享的 Bean 实例，并且所有对 Bean 的请求，只要 id 与该 bean 定义相匹配，则只会返回 bean 的同一实例。

2. **原型：** 当一个 bean 的作用域为 prototype，表示一个 bean 定义对应多个对象实例。prototype 作用域的 bean 会导致在每次对该 bean 请求时都会创建一个新的 bean 实例。因此，每次请求都会得到一个新的 Bean 实例。

3. **请求：** 一个HTTP请求对应一个Bean实例，每个请求都有自己的Bean实例，且该Bean仅在请求期间有效。

4. **会话：** 在一个HTTP会话中，一个Bean定义对应一个实例。

5. **应用程序：** 对于定义在ServletContext中的Bean，整个Web应用程序共享一个Bean实例。

6. **Websocket:** WebSocket生命周期内，每个WebSocket会话拥有一个Bean实例。

---

### Bean的生命周期

Spring Bean的生命周期，其实就是Spring容器从创建Bean到销毁Bean的整个过程。这里面有几个关键步骤：

1. **实例化Bean:** Spring容器通过构造器或工厂方法创建Bean实例。

2. **设置属性：** 容器会注入Bean的属性，这些属性可能是其他Bean的引用，也可能是简单的配置值。

3. **检查Aware接口并设置相关依赖：** 如果Bean实现了BeanNameAware或BeanFactoryAware接口，容器会调用相应的setBeanName或setBeanFactory方法。

4. **BeanPostProcessor：** 在Bean的属性设置之后，Spring会调用所有注册的BeanPostProcessor的postProcessBeforeInitialization方法。

5. **初始化Bean:** 如果Bean实现了InitializingBean接口，容器会调用其afterPropertiesSet方法。同时，如果Bean定义了init-method，容器也会调用这个方法。

6. **BeanPostProcessor的第二次调用：** 容器会再次调用所有注册的BeanPostProcessor的postProcessAfterInitialization方法，这次是在Bean初始化之后。

7. **使用Bean：** 此时，Bean已经准备好了，可以被应用程序使用了。

8. **处理DisposableBean和destroy-method：** 当容器关闭时，如果Bean实现了DisposableBean接口，容器会调用其destroy方法。如果Bean定义了destroy-method，容器也会调用这个方法。

9. **Bean销毁：** 最后，Bean被Spring容器销毁，结束了它的生命周期。

---

### Spring循环依赖是怎么解决的

#### 什么是循环依赖

两个或者两个以上的 bean 互相持有对方，最终形成闭环。比如 Bean A 依赖于 Bean B，而 Bean B 又依赖于 Bean A，形成了一个循环依赖关系。这种情况下，如果不处理，会导致 Spring 容器无法完成 Bean 的初始化，从而抛出循环依赖异常。

#### 怎么检测是否存在循环依赖

检测循环依赖相对比较容易，Bean在创建的时候可以给该Bean打标，如果递归调用回来发现正在创建中的话，即说明了循环依赖了。

#### 如何解决

- **构造器循环依赖：** Spring容器在创建Bean时，如果遇到循环依赖，通常是无法处理的，因为这会导致无限递归创建Bean实例。所以，构造器注入是不支持循环依赖的。

- **字段注入或Setter注入：** 使用了三级缓存来解决循环依赖问题。
    - 首先，Spring容器会创建一个Bean的原始实例，但此时Bean的属性尚未设置，这个实例被存放在一级缓存中。
    - 当Bean的属性被设置时，如果属性值是其他Bean的引用，Spring会去检查二级缓存，看是否已经有该Bean的引用存在。
    - 如果二级缓存中没有，Spring会尝试创建这个被引用的Bean，并将其放入三级缓存。
    - 最后，当Bean的属性设置完成后，原始的Bean实例会被放入二级缓存，供其他Bean引用

- **使用@Lazy注解：** 通过@Lazy注解，可以延迟Bean的加载，直到它被实际使用时才创建，这可以避免一些循环依赖的问题。

---

### Spring 中用到了那些设计模式

- **工厂设计模式:** Spring 使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。

- **代理设计模式:** Spring AOP 功能的实现。

- **单例设计模式:** Spring 中的 Bean 默认都是单例的。

- **模板方法模式:** Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。

- **包装器设计模式:** 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。

- **观察者模式:** Spring 事件驱动模型就是观察者模式很经典的一个应用。

- **适配器模式:** Spring AOP 的增强或通知 (Advice) 使用到了适配器模式、Spring MVC 中也是用到了适配器模式适配 Controller。

---

### 描述一下SpringMVC的执行流程

1. 用户发送请求至前端控制器 DispatcherServlet。

2. DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器。

3. 处理器映射器找到具体的处理器(可以根据 xml 配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给 DispatcherServlet。

4. DispatcherServlet 调用 HandlerAdapter 处理器适配器。

5. HandlerAdapter 经过适配调用具体的处理器(Controller，也叫后端控制器)。

6. Controller 执行完成返回 ModelAndView。

7. HandlerAdapter 将 controller 执行结果 ModelAndView 返回给 DispatcherServlet。

8. DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器。

9. ViewReslover 解析后返回具体 View。

10. DispatcherServlet 根据 View 进行渲染视图(即将模型数据填充至视图中)

11. DispatcherServlet响应用户。

---

### SpringBoot Starter有什么用

Spring Boot Starter 的作用是简化和加速项目的配置和依赖管理。

- Spring Boot Starter 可以理解为一种预配置的模块，它封装了特定功能的依赖项和配置, ，开发者只需引入相关的 Starter 依赖，无需手动配置大量的参数和依赖项。常用的启动器包括 spring-boot-starter-web（用于Web应用）、spring-boot-starter-data-jpa（用于数据库访问）等。 引入这些启动器后，Spring Boot 会自动配置所需的组件和 Bean，无需开发者手动添加大量配置。

- Starter还管理了相关功能的依赖项，包括其他Starter和第三方库，确保它们能够良好地协同工作，避免版本冲突和依赖问题。

- Spring Boot Starter 的设计使得应用可以通过引入不同的Starter来实现模块化的开发。每个Starter都关注一个特定的功能领域，如数据库访问、消息队列、Web开发等。

- 开发者可以创建自定义的 Starter，以便在项目中共享和重用特定功能的配置和依赖项。

---

### SpringBoot的常用注解

1. **@SpringBootApplication：** 用于标识主应用程序类，通常位于项目的顶级包中。这个注解包含了 @Configuration、@EnableAutoConfiguration 和 @ComponentScan。

2. **@Controller：** 用于标识类作为 Spring MVC 的 Controller。

3. **@RestController：** 类似于 @Controller，但它是专门用于 RESTful Web 服务的。它包含了 @Controller 和 @ResponseBody。

4. **@RequestMapping：** 用于将HTTP请求映射到 Controller 的处理方法。可以用在类级别和方法级别。

5. **@Autowired：** 用于自动注入 Spring 容器中的 Bean，可以用在构造方法、字段、Setter 方法上。

6. **@Service：** 用于标识类作为服务层的 Bean。

7. **@Repository：** 用于标识类作为数据访问层的 Bean，通常用于与数据库交互。

8. **@Component：** 通用的组件注解，用于标识任何 Spring 托管的 Bean。

9. **@Configuration：** 用于定义配置类，类中可能包含一些 @Bean 注解用于定义 Bean。

10. **@EnableAutoConfiguration：** 用于启用 Spring Boot 的自动配置机制，根据项目的依赖和配置自动配置 Spring 应用程序。

11. **@Value：** 用于从属性文件或配置中读取值，将值注入到成员变量中。

12. **@Qualifier：** 与 @Autowired 一起使用，指定注入时使用的 Bean 名称。

13. **@ConfigurationProperties：** 用于将配置文件中的属性映射到 Java Bean。

14. **@Profile：** 用于定义不同环境下的配置，可以标识在类或方法上。

15. **@Async：** 用于将方法标记为异步执行。

---

### JDK8新特性

1. **Lambda 表达式：** 允许以更简洁的语法编写匿名函数。

2. **Stream API：** Stream API 提供了一种声明式的方式来对集合进行操作。它支持各种操作，如过滤、映射、排序、归约等。

3. **函数式接口：** Java 8 提供了一系列函数式接口，如 Consumer、Predicate、Function 等。

4. **新的日期和时间 API：** Java 8 引入了 java.time 包，提供了全新的日期和时间 API。它解决了旧的 java.util.Date 和 java.util.Calendar 的诸多问题，并提供了更加清晰和易用的日期和时间处理方式。

5. **方法引用：** 方法引用允许通过方法的名称来引用一个方法，而不是执行它。它们提供了一种更简洁的方式来传递方法作为参数，如 System.out::println。

---

### 测开

#### 为什么选择软件测试/测开这个行业呢？

##### 1、为什么选择测试开发

答：首先，我认为的测开是测试和开发工作都在做的。一方面，据我了解，在近几年，国内对软件测试越来越重视，并且从用户角度来说，对于同类产品，可能会更加注重产品的质量和服务，所以我觉得测试的发展前景是非常好的。其次，测试在一个项目开发的过程中是非常重要的一环。测试人员的责任非常大，责任越大成就感就越大。我很喜欢这样的工作。另一方面，测开还有一部分开发工作，无论是自动化脚本还是测试工具或框架，都提高了测试的效率，为质量效率保证工作提供了有力的保障。并且测开的所需技术广度也是很高，所以我认为测开会激发我对这个岗位的热爱和持续学习的态度。（并且来说，我目前具备了一些测开所必备的理论知识和技能并且还在不断地学习中，我认为我可以较快地胜任这个岗位。）

##### 3、为什么选择测试：

答：一方面我做事情和处理问题喜欢刨根问底，喜欢把问题全都找出来再一一解决，喜欢并享受这个过程，另一方面因为国内计算机已经过了野蛮发展的阶段，所以以后在存量市场是以用户体验和质量取胜的，而测试是这其中最关键的一环，所以肯定会越来越受到重视，选择测试是看中了发展的前景，并且个人很喜欢站在客户的角度去看待产品，很适合这个行业，所以我选择测试。

---

### 你觉得一个测试/测开应该具备哪些知识和能力

#### 知识
- **编程技能：** 测试人员需要掌握至少一种编程语言，Java、Python，能够编写一些自动化测试脚本和工具。
- **掌握测试基本知识，** 比如理解不同类型的测试，如单元测试、集成测试、系统测试和验收测试，掌握黑盒测试和白盒测试的原理和适用场景。
- **知道如何进行测试需求分析，** 并能够设计有效的测试用例和测试计划。
- **熟悉常用的的测试工具和框架，** 例如Selenium，JMeter等。

#### 能力
- **分析能力：** 测试开发首先要能够理解复杂的软件系统和业务需求，并设计有效的测试用例。
- **技术能力：** 对于测试开发职位，编程能力也是必要的，测试开发要求测试人员了解不同的编程语言和测试框架，能够编写自动化测试脚本。
- **细节和认真观察的能力：** 测试要对细节高度敏感，善于发现bug。
- **沟通能力：** 要与开发团队、产品经理进行沟通，确保测试的结果被正确传达。
- **学习能力：** 测试是一个不断发展的领域，需要学习相关的测试知识和业务知识。
- **解决问题的能力：** 遇到问题时，能够有效地分析问题根源并提出解决方案。

---

### 在项目中如何保证软件质量？时间紧张如何开展测试工作呢？【已添加】

#### 如何保证软件质量

项目质量不仅仅是某个人或某个团队来保障的，而是整个团队一起努力的结果，在公司级别需要有一个规范的项目流程
- **产品，** 保证迭代过程中的产品逻辑，对于可能的兼容，升级做出预判，并给出方案
- **设计，** 满足产品表达的同时，保证设计的延续性
- **开发，** 产品细节的保证，技术方案选择要严谨，考虑兼容，性能，开发完成后要充分自测，严格遵循开发规范操作
- **测试，** 验证产品逻辑，站在用户角度对交互设计进行系统验证，尽可能多的使用技术手段保证测试质量

#### 时间紧张如何做？
- 测试尽量提前介入，提前开展工作
- 要求开发自测，提高提测质量
- 对于重复执行的回归测试，如果可以的话，使用技术手段做成自动化，提高测试效率
- 根据模块和功能的重要性和优先级，合理安排测试顺序
- 有必要的话，向领导申请更多的测试资源和人力或者通过加班来追赶下进度

---

### 常用的测试工具有哪些？【已添加】

#### 自动化测试
- **Selenium：** 用于自动化Web应用程序测试的工具，支持多种浏览器和多种编程语言。
- **Appium：** 移动应用自动化测试框架。

#### 接口测试
- **Postman/Apifox:** 用于API开发和测试的流行工具
- **Swagger UI：** 用于设计、构建、文档化和测试REST API的工具。

#### 性能测试
- **JMeter：** 用于Web应用程序性能测试和压力测试的工具。
- **LoadRunner：** 性能测试工具，模拟多用户并发。

#### 单元测试
- **Pytest：** 用于Python应用程序的测试框架，支持简单和复杂的测试场景。
- **JUnit：** 用于Java应用程序的单元测试框架，支持自动化测试脚本的执行和报告生成。

#### 抓包工具
- **Fiddler：** 网络调试代理工具，用于捕获和分析HTTP/HTTPS流量。
- **Wireshark：** 网络协议分析工具，用于深入分析网络数据包。

---

### 讲一下你们的测试流程【已添加】

我参与项目和实习中的测试流程通常按照下面这些步骤进行：

1. **需求分析：** 测试首先要对软件需求有着深入的理解，所以我们会开需求评审会议，分析和讨论需求。

2. **制定测试计划：** 明确测试的范围、方法、资源分配、时间表和目标。

3. **测试用例设计：** 基于测试计划，设计详细的测试用例。这些用例应该覆盖所有功能点，包括正常情况和边界情况的测试。

4. **测试用例评审**

5. **搭建和配置适合的测试环境，** 执行测试用例，记录测试结果（找 bug), 将在测试过程中发现的缺陷报告给开发团队

6. **回归测试：** 每当代码发生更改后，执行回归测试以确保新的更改没有破坏现有的功能

7. **性能测试：** 评估系统的响应时间、稳定性和扩展性。

8. **部署项目到预生产环境，** 在预生产环境测试

9. **编写测试报告，** 总结测试活动的结果，包括测试覆盖率、发现的缺陷和未解决的问题。

10. **项目上线后，** 根据反馈进行复盘和总结。

---

### 软件测试分为哪几个阶段？【已添加】

1. **功能测试：** 检查软件的各项功能是否按照需求规格书执行，包括用户界面、数据库、安全性、功能等。

2. **单元测试：** 测试软件中最小的可测试部分，验证这些单元在各种条件下都按预期工作

3. **集成测试：** 测试多个单元、模块或组件协同工作时是否能正常运行。

4. **系统测试：** 测试完整的、集成的软件系统来评估系统的符合度。通常包括功能性和非功能性测试。

5. **回归测试：** 在发生修改之后重新测试先前的测试用例以保证修改的正确性。

6. **性能测试：** 检查软件的速度、响应时间、稳定性、资源消耗等性能指标。包括负载测试、压力测试和稳定性测试。

7. **验收测试：** 确定软件是否满足其业务需求。验收测试是软件交付之前的最后一阶段测试。验收测试包括Alpha测试和Beta测试。
    - **Alpha测试：** 是由用户在开发者的场所来进行的，在一个受控的环境中进行。
    - **Beta测试：** 由软件的最终用户在一个或多个用户场所来进行的，开发者通常不在现场，用户记录测试中遇到的问题并报告给开发者，开发者对系统进行最后的修改，并开始准备发布最终的软件

---

### 如何定位bug 是给前端还是后端 【已添加】

1. 首先复现问题，确保能够可靠地重现这个bug。记录重现bug的具体步骤、输入、环境设置等。

2. 查看错误日志，通过查看客户端/服务端的日志，分析有没有异常的日志信息，从而确定具体原因

3. 分析客户端：使用开发者工具（如浏览器的开发者控制台）来检查网络请求、响应数据、控制台输出等，如果客户端收到的响应数据是正确的，但表现异常，可能是客户端问题

4. 分析服务端：检查服务端的处理逻辑。确保服务端正确处理了来自客户端的请求，并返回了正确的响应。如果服务端在处理请求时出现错误或返回了错误的数据，问题可能在服务端

5. 验证网络通信：还要确认客户端和服务端之间的网络通信是否正常。有的时候网络问题可能会导致错误。

---

### 你在测试中发现了一个bug，但是开发认为这不是一个bug，你应该怎样解决？【已添加】

1. 告知开发bug的判断依据，同时明确开发说不是bug的理由。

2. 对开发的理由进行校验，校验依据
    - 参照需求文档
    - 跟产品经理进行沟通确认

3. 校验结果不是bug，关闭bug，如果是bug提交给开发进行处理，确保产品质量

---

### bug的生命周期 【已添加】

1. **New:（新的）** 当某个"bug"被第一次发现的时候，测试人员需要与项目负责人沟通以确认发现的的确是一个bug，如果被确认是一个bug，就将其记录下来，并将bug的状态设为New

2. **Assigned（已指派的）** 当一个bug被指认为New之后，将其反馈给开发人员，开发人员将确认这是否是一个bug，如果是，开发组的负责人就将这个bug指定给某位开发人员处理，并将bug的状态设定为"Assigned"

3. **Open（打开的）** 一旦开发人员开始处理bug的时候，他（她）就将这个bug的状态设置为"Open"，这表示开发人员正在处理这个"bug

4. **Fixed（已修复的）** 当开发人员进行处理（并认为已经解决）之后，他就可以将这个bug的状态设置为"Fixed"并将其提交给开发组的负责人，然后开发组的负责人将这个bug返还给测试组

5. **Pending Reset（待在测试的）** 当bug被返还到测试组后，我们将bug的状态设置为Pending Reset"

6. **Reset(再测试)** 测试组的负责人将bug指定给某位测试人员进行再测试，并将bug的状态设置为"Reset"

7. **Closed（已关闭的）** 如果测试人员经过再次测试之后确认bug 已经被解决之后，就将bug的状态设置为"Closed"

8. **Reopen（再次打开的）** 如果经过再次测试发现bug（指bug本身而不是包括因修复而引发的新bug）仍然存在的话，测试人员将bug再次传递给开发组，并将bug的状态设置为"Reopen"

9. **Pending Reject（拒绝中）** 如果测试人员传递到开发组的bug被开发人员认为是正常行为而不是bug时，这种情况下开发人员可以拒绝，并将bug的状态设置为"Pending Reject"

10. **Rejected(被拒绝的)** 测试组的负责人接到上述bug的时候，如果他（她）发现这是产品说明书中定义的正常行为或者经过与开发人员的讨论之后认为这并不能算作bug的时候，开发组负责人就将这个bug的状态设置为"Rejected"

11. **Postponed（延期）** 有些时候，对于一些特殊的bug的测试需要搁置一段时间，事实上有很多原因可能导致这种情况的发生，比如无效的测试数据，一些特殊的无效的功能等等，在这种情况下，bug的状态就被设置为"Postponed"

---

### 你对单元测试和集成测试有哪些了解

1. **单元测试**是针对软件的最小可测试部分（通常是一个函数、方法或类）进行的测试。通常在编写或修改代码后立即进行，以快速发现和修正代码中的错误，常用的工具包括JUnit（Java）、PyTest（Python）等。

2. **集成测试**是在多个模块或组件被集成在一起后进行的测试，用来验证不同模块之间的接口和交互是否按预期工作，通常使用集成测试框架，比如Postman（API测试）、Selenium（Web应用集成测试）来进行。

---

### 系统测试和集成测试的区别和使用场景是什么

1. **系统测试**是在整个软件系统完成集成后进行的测试。它的目的是验证整个系统是否符合指定的需求，关注整个系统的行为，测试涵盖所有集成的模块，以确保它们作为一个完整的系统正确地协同工作，包含功能性测试（如功能完整性、用户界面、用户流程）和非功能性测试（如性能、安全性、兼容性）。

2. **集成测试**是在多个软件模块或组件被集成在一起时进行的测试。它的目的是验证这些模块或组件之间的交互，关注于模块之间的接口和交互。确保不同模块的数据交换和功能协作符合预期，主要用来检查数据传递、接口调用、异常处理等模块间交互的方面。

3. **集成测试**通常在单元测试之后、系统测试之前进行，当整个应用开发接近完成时，进行系统测试。

---

### 什么是黑盒测试和白盒测试

1. **黑盒测试，** 也被称为功能测试或行为测试，测试者只关注软件的输入和输出，不需要了解程序的内部实现，主要验证软件的功能是否符合用户需求和规格说明。常用的测试方法包括等价类划分、边界值分析、因果图法、状态转换测试、错误猜测等。

2. **白盒测试，** 也称为结构测试或透明盒测试，测试者需要了解程序的内部工作机制，包括代码、逻辑流程、内部结构，主要验证代码的逻辑路径、分支覆盖、循环、语句覆盖等，常用的测试方法包括路径覆盖、条件覆盖、循环覆盖、语句覆盖等，主要适用于单元测试和集成测试。

---

### 说一下等价类划分和边界值分析法

#### 等价类划分

等价类划分是将系统的输入域划分为若干部分，然后从每个部分选取少量代表性数据进行测试。等价类划分认为如果一个测试用例在某个等价类中的一个值上通过测试，那么它在这个类中的其他值上也会通过，适用于输入数据较多的情况，有助于减少测试用例的数量并保证覆盖率。

- **有效等价类：** 符合规格说明的输入条件。
- **无效等价类：** 不符合规格说明的输入条件。

通过测试有效等价类来验证系统的正确性，通过无效等价类来验证系统的健壮性。

#### 边界值法

软件错误往往发生在输入或输出范围的边缘，所以边界值分析专注于测试输入数据的边界条件，而不是中间值，包括正常边界值（最大、最小值）和异常边界值（最大值+1、最小值-1），适用于测试那些对输入数据有明确范围或限制的功能。

---

### 测试报告应该包含哪些内容？

1. **测试概况：** 测试过程的总体概述，包括测试的目标、范围、方法等。

2. **测试环境：** 测试所使用的硬件、软件环境的详细描述。

3. **测试用例和执行情况：** 测试用例的设计和执行情况的统计，用于评估测试的覆盖率和效果。

4. **问题列表：** 测试过程中发现的问题和缺陷清单，包括问题的严重程度、影响范围、修复建议等。

5. **测试结论和建议：** 根据测试结果进行软件质量评估和提出改进建议。

---

### 软件质量的六个特征

1. **功能性：** 表示软件能够提供满足明确和隐含需求的功能。

2. **可靠性：** 软件在各种条件下都能稳定运行，不出现意外故障。

3. **效率：** 软件响应迅速，资源消耗合理，满足性能要求。

4. **易用性：** 软件界面友好，用户容易理解和操作。

5. **可维护性：** 在必要时能够有效地进行修正和改进软件的能力。

6. **可移植性：** 表示软件能够从一个环境迁移到另一个环境的能力。

---

### 功能测试用例一般包含哪些内容

1. **测试用例ID：** 一个唯一标识符，用于区分和引用测试用例。

2. **用例优先级：** 该测试用例的优先执行程度。

3. **测试用例标题：** 简短描述测试用例的目的或主要功能。

4. **功能模块：** 指明此测试用例所属的软件功能模块或部分。

5. **测试目的/描述：** 对测试用例的目标和测试内容的详细描述。

6. **前置条件：** 执行测试用例之前需要满足的条件，如特定的系统状态或配置。

7. **测试步骤：** 详细描述如何执行测试，包括用户如何与系统交互，每一步应该输入什么数据，选择哪些选项等。

8. **测试数据：** 在测试中使用的具体数据，包括输入值和需要验证的输出值。

9. **预期结果：** 描述在成功执行测试步骤后预期的系统行为或输出。

10. **实际结果：** 在执行测试后记录的实际结果，用于与预期结果进行比较。

11. **通过/失败标准：** 定义何种条件下测试用例被认为是通过或失败。

12. **测试环境：** 描述执行测试用例所需的软件、硬件、网络配置等环境信息。

13. **备注信息：** 任何额外的信息，比如相关的依赖、特殊注意事项等。

14. **缺陷/问题ID：** 如果测试失败，关联的缺陷或问题的标识符。

---

### 说一下设计测试用例有哪些方法

#### 黑盒测试方法：
- **等价类划分法：** 将输入数据划分为不同的等价类，每个等价类都有相似的行为。然后从每个等价类中选择测试用例。
- **边界值分析法：** 关注输入值的边界情况，测试接近边界值和边界之间的情况。
- **因果图法：** 使用因果图来识别和描述系统中各种因果关系，辅助设计测试用例。
- **决策表测试：** 创建决策表，列出不同的输入组合和相应的输出，确保所有可能的组合都得到测试。
- **状态转换测试：** 适用于有状态的系统，测试系统在不同状态下的行为和状态之间的转换。
- **错误推测法：** 基于错误的假设来设计测试用例，以发现可能的缺陷。

#### 白盒测试方法：
- **语句覆盖：** 确保每个源代码语句都至少执行一次。测试用例的目标是覆盖代码的所有语句。
- **分支覆盖：** 确保每个分支语句都至少执行一次，以测试代码中的条件语句。
- **路径覆盖：** 通过执行代码的所有可能路径来测试系统，包括所有可能的条件分支和循环。
- **条件覆盖：** 测试代码中条件表达式的所有可能取值，以确保所有条件的不同情况都被覆盖。
- **循环覆盖：** 确保测试覆盖了循环的不同情况，包括循环的入口、中间和退出。

---

### 如何写测试用例

- **测试人员尽早介入，** 彻底理解清楚需求，这个是写好测试用例的基础
- 如果以前有类似的需求，可以参考类似需求的测试用例，然后还需要看类似需求的bug情况
- 清楚输入、输出的各种可能性，以及各种输入的之间的关联关系，理解清楚需求的执行逻辑，通过等价类、边界值、判定表等方法找出大部分用例
- 找到需求相关的一些特性，补充测试用例
- 根据自己的经验分析遗漏的测试场景
- 多总结类似功能点的测试点，才能够写出质量越来越高的测试用例

---

### 如何提高用例的覆盖率，减少漏测

1. 根据需求文档编写用例，确保每条需求都能被对应的用例覆盖

2. 要充分理解业务，挖掘隐形需求，并编写对应的用例

3. 除了正常的业务场景，多考虑一些异常的场景和数据

4. 要从多个维度对软件进行测试，功能、性能、安全等各方面来考虑

5. 多站在用户的角度去思考问题，模拟用户的使用场景

6. 组织用例评审

---

### 测试方法了解有哪些？

1. **黑盒测试：** 验证软件的功能是否符合用户需求和规格说明

常用的黑盒测试方法有：等价类划分法；边界值分析法；因果图法；场景法；正交实验设计法；判定表驱动分析法；错误推测法；功能图分析法。

2. **白盒测试：** 验证代码的逻辑路径

白盒测试方法有路径覆盖、条件覆盖、循环覆盖、语句覆盖等。

---

### 为什么要做接口测试, 你是怎么测试接口的

#### 为什么要做接口测试

- 在公司里，客户端和服务端通常是由不同的团队开发的，在项目开发过程中，客户端和服务端开发的进度不一致，比如服务端先开发完了，这个时候可以先对服务端进行接口测试，确保服务端逻辑和返回数据是正确的，然后再测试客户端。另外某些测试部门，专门测试服务端开发团队，因此，他们的测试对象就是接口。

- 在测试某些业务时，不能仅仅通过前端来测试，比如用户注册，前端限制了用户名不能为空，但是有些人可能通过工具绕过前端直接调用服务端接口，如果服务端没有做相关的逻辑判断，就会造成数据错误。包括接口数据传输过程中是否对关键信息加密等。所以必须针对服务端接口单独做测试。

- 在开发提测后，可以先通过工具把服务端的接口测试跑一遍，确保接口测试用例都是通过的，快速判断服务端接口是否符合预期。然后再通过UI界面进行测试。否则接口有bug，前端页面必定有bug。

#### 怎么测试接口的

- 理解接口文档，了解接口的业务功能，请求方法、请求参数、响应结构、错误码以及对应的数据库存储

- 编写测试用例，涵盖正常的输入情况（验证接口的功能性）和异常的输入情况（验证接口的健壮性和错误处理

- 使用测试工具，比如 Postman执行测试用例，观察响应是否符合预期，验证响应的状态码、响应体内容、响应时间等、

- 结果验证和报告，验证测试结果，并编写测试报告，记录发现的问题和测试结论。

---

### 接口测试用例的编写需要注意哪些要点

1. **明确接口规格：** 理解接口的功能、输入输出参数、数据格式、请求方法（如GET、POST、PUT、DELETE等）和预期的行为。

2. **返回值：** 各种情况下（正确的输入值和异常的输入值）下的响应内容是否正常。

3. **接口的业务逻辑和功能是否正常。**

4. **数据库校验。**

5. **性能测试**（接口TPS, 响应时间等）。

6. **安全性：** 敏感信息加密，权限控制等。

---

### 你使用过哪些接口测试的工具

- **Postman:** API测试工具，用于发送各种HTTP请求，易于使用，适合快速测试RESTful API，并且可以组织和分享API测试集合，也支持自动化测试脚本编写。

- **Apifox:** 集API设计、开发、测试于一体的协作工具, 功能强大，适合团队协作。

- **JMeter:** 主要用于性能测试和负载测试，但也可以用于API测试。

- **Swagger UI：** 用于设计、构建、文档化和测试REST API的工具

---

### 接口测试流程

接口测试流程大体和功能测试流程一样（区别在于多了接口文档，使用工具执行测试）

1. 分析需求文档和接口文档（URL、入参、返回值等）
2. 制定测试计划
3. 根据需求文档编写接口测试用例
4. 测试用例评审
5. 根据用例，使用接口测试工具执行测试
6. 提交bug、回归测试
7. 预生产环境测试
8. 输出接口测试报告
9. 上线

---

### 性能测试中，一般关注哪些指标

做性能测试的目标是，在大用户量、数据量的超负荷下，获得服务器运行时的相关数据，从而分析出系统瓶颈，提高系统的稳定性。

- **TPS吞吐量:** 系统在单位时间内处理请求的数量，代表了性能的好坏，TPS越高，性能越好

- **平均响应时间：** 接口从请求到响应、返回的时间。请求的平均消耗时间，时间越短，性能越好

- **并发用户数:** 同一时间点请求服务器的用户数，支持的最大并发数。

- **错误率：** 失败的请求比例。

- **内存占用：** 内存开销。

- **资源使用率：** CPU占用率、内存使用率、磁盘I/O、网络I/O。

---

### 说一说你知道的自动化测试框架有哪些？

1. **Selenium：** 广泛用于Web应用的自动化测试，提供了丰富的API来模拟用户在浏览器中的操作，如点击、输入文本和选择下拉菜单等。它还支持各种浏览器和操作系统。

2. **Appium：** 用于移动应用程序的自动化测试框架，它支持iOS和Android平台上的原生、混合和移动Web应用程序。

3. **Junit:** 用于Java应用程序的单元测试框架。它提供了一种编写可重复的测试用例的方法，并且能够自动运行这些测试用例并生成详细的测试报告。JUnit还支持参数化测试和测试套件，方便组织和管理大量的测试用例。

4. **TestNG：** TestNG 是一个基于 Java 的测试框架，可以用于编写和运行各种类型的测试，包括单元测试、集成测试和端到端测试。它提供了丰富的注解和配置选项，支持并行执行和数据驱动测试，可以生成详细的测试报告。

5. **Robot Framework：** Robot Framework 是一个通用的自动化测试框架，支持多种应用程序和平台。它使用关键字驱动的测试方法，支持多种编程语言和关键字库，并提供了丰富的测试库和插件，方便编写和管理测试用例。

6. **JMeter：** 主要用于性能测试，但也可用于自动化测试某些接口。

---

### App 测试和 Web 测试有什么区别

#### Web和App的区别
- **Web 项目，** 一般都是b/s架构，基于浏览器的。
- **App则是C/S的，** 必须要有客户端。那么在系统测试的时候就会产生区别了。

首先从系统架构来看的话，Web测试只要更新了服务器端，客户端就会同步会更新。而且客户端是可以保证每一个用户的客户端完全一致的。但是App端是不能够保证完全一致的，除非用户更新客户端。如果是App下修改了服务端，意味着客户端用户所使用的核心版本都需要进行回归测试一遍。

#### 性能方面
- **Web项目，** 需要检测响应时间、CPU 、内存
- **App项目，** 除了响应时间、CPU 、内存外，还需测试GPU、流量、电量

#### 兼容方面
- **Web** 是基于浏览器的，所以更倾向于浏览器和电脑硬件，电脑系统的方向的兼容，不过一般还是以浏览器的为主。而浏览器的兼容则是一般是选择不同的浏览器内核进行测试（IE、chrome、Firefox）。
- **App的测试** 则必须依赖Phone或者是Pad，不仅要看分辨率，屏幕尺寸，还要看设备系统。系统总的来说也就分为Android和iOS，不过国内的Android的定制系统太多，也是比较容易出现问题的。

#### 相比较Web测试，App更是多了一些专项测试：

- **一些异常场景的考虑以及弱网络测试。** 这里的异常场景就是中断，来电，短信，关机，重启等。而弱网测试是App测试中必须执行的一项测试。包含弱网和网络切换测试。需要测试弱网所造成的用户体验，重点要考虑回退和刷新是否会造成二次提交。需要测试丢包，延时的处理机制。避免用户的流失。

- **安装、卸载、更新：** web测试是基于浏览器的所以不必考虑这些。而app是客户端的，则必须测试安装、更新、卸载。除了常规的安装、更新、卸载还要考虑到异常场景。包括安装时的中断、弱网、安装后删除安装文件，更新的强制更新与非强制更新、增量包更新、断点续传、弱网，卸载后删除App相关的文件等等。

- **界面操作** 现在app产品的用户都是使用的触摸屏手机，所以测试的时候还要注意手势，横竖屏切换，多点触控，事件触发区域等测试。

#### 测试工具
- 自动化工具：APP 一般使用 Appium; Web 一般使用 Selenium
- 性能测试工具：APP 一般使用 JMeter; Web 一般使用 LR、JMeter

---

### selenium定位元素方法

- 使用元素的 ID 进行定位
- 使用元素的name进行定位
- 使用元素的 class 属性进行定位。
- 通过元素的标签名进行定位。
- 使用 CSS 选择器进行定位。
- 通过元素的任意属性进行定位。
- 使用链接元素的完整文本进行定位。
- 使用 XPath 表达式进行定位

---

### fiddler 的工作原理是什么?在项目测试过程中主要在哪些场景下使用？

fiddler其实就是在客户端和服务端之间起到了一个代理的作用，它可以监听客户端和服务端的HTTP通信，把请求和响应的数据都抓下来，另外还可以做请求/响应拦截，修改报文，以及弱网测试等。

a) 当测试出bug时，可以通过fiddler抓包，分析bug是客户端还是服务端的问题

b) 当做接口测试时，通过抓包获取接口的入参和返回值，包括接口之间的数据关联

c) 当对客户端做弱网测试，可以修改fiddler的网络模拟参数，模拟出不同的网络速度

d) 当需要对客户端测试一下特殊场景，可以使用fiddler设置响应断点（bpu、bpafter），修改服务端响应的数据，测试客户端对应的逻辑处理，比如修改服务端返回的状态为500

---

### jmeter做接口测试的流程

1. 通过接口文档，或者抓包，获取接口的url和参数

2. 创建线程组、HTTP请求，根据接口地址设置相关的信息

3. 根据测试用例情况，修改接口参数，调用接口

4. 对接口返回值做判断（断言）

---

### 定位不到元素的原因

自动化定位不到元素的原因有：
1. 定位器选择错误
2. 定位字符串错误
3. 元素嵌套在frame当中
4. 页面元素没有及时加载
5. 元素在新窗口中
6. 脚本流程与实际不符
7. 元素不在当前页

---

### 给你一个页面，你如何测试？

1. **功能测试：** 检查页面的所有功能是否按预期工作，包括链接地址、表单提交和用户交互。

2. **UI测试：** 验证页面的布局、颜色和字体是否符合设计要求。

3. **性能测试：** 评估页面加载时间和响应速度

4. **安全性测试：** 通过输入特殊字符，sql注入，脚本注入测试等方式检查页面的输入验证（比如信息提交是否验证，数据传输是否加密），从而发现潜在的安全漏洞。

5. **兼容性测试：** 在不同的浏览器和设备上测试页面，确保兼容性。

6. **易用性测试：** 模拟用户操作，确保用户能够顺畅地完成任务。

---

### 如果做一个杯子的检测，你怎么测试

#### 功能测试点
- 杯子是否能够正常盛装水或者其他液体
- 杯子的容量，是否有刻度表
- 密封后，是否漏水
- 杯子是否可以保温和隔热

#### 界面测试点
- 评估杯子的外观、颜色和形状。
- 评估杯子的重量。
- 评估杯子是否有异味。

#### 性能测试点
- 杯子可以使用多长时间
- 杯子的刻度是否准确
- 杯子的保温时间
- 杯子的隔热性能
- 杯子是否容易漏水
- 杯子的磨损性

#### 安全测试点
- 杯子的制作材质是否安全
- 杯子是否容易破碎。
- 杯子加热后是否会爆炸或熔化。
- 杯子是否有缺口，容易划伤。
- 杯子是否容易长细菌。

#### 易用性测试点
- 评估杯子使用时的舒适度和便利性。
- 杯子是否烫手。

#### 兼容性测试点
- 杯子能够容纳其他液体
- 杯子是否适用于各种环境

---

### 微信发红包

#### 功能测试
- 在红包钱数，和红包个数的输入框中只能输入数字
- 红包里最多和最少可以输入的钱数 200 0.01
- 拼手气红包最多可以发多少个红包 100
- 超过最大拼手气红包的个数是否有提醒
- 当红包钱数超过最大范围是不是有对应的提示
- 当发送的红包个数超过最大范围是不是有提示
- 当余额不足时，红包发送失败
- 在红包描述里是否可以输入汉字，英文，符号，表情，纯数字，汉字英语符号，是否可以输入它们的混合搭配
- 输入红包钱数是不是只能输入数字
- 红包描述里许多能有多少个字符 10个
- 红包描述，金额，红包个数框里是否支持复制粘贴操作
- 红包描述里的表情可以删除
- 发送的红包别人是否可以领
- 发的红包自己可不可以领取 2人
- 24小时内没有领取的红包是否可以退回到原来的账户, 超过24小时没有领取的红包，是否还可以领取
- 用户是否可以多次抢一个红包
- 红包的金额里的小数位数是否有限制
- 可以按返回键，取消发红包
- 断网时，无法抢红包
- 可不可以自己选择支付方式
- 余额不足时，会不会自动匹配支付方式
- 在发红包界面能否看到以前的收发红包的记录
- 红包记录里的信息与实际收发红包记录是否匹配
- 支付时可以密码支付也可以指纹支付
- 如果直接输入小数点，那么小数点之前应该有个0
- 支付成功后，退回聊天界面
- 发红包金额和收到的红包金额应该匹配
- 是否可以连续多次发红包
- 输入钱数为0，"塞钱进红包"置灰

#### 性能
- 弱网时抢红包，发红包时间
- 不同网速时抢红包，发红包的时间
- 发红包和收红包成功后的跳转时间
- 收发红包的耗电量
- 退款到账的时间

#### 兼容
- 苹果，安卓是否都可以发送红包
- 电脑端可以抢微信红包

#### 界面
- 发红包和收红包界面排版合理
- 发红包和收到红包界面颜色搭配合理

#### 安全
- 对方微信号异地登录，是否会有提醒 2人
- 红包被领取以后，发送红包人的金额会减少，收红包金额会增加
- 发送红包失败，余额和银行卡里的钱数不会少
- 红包发送成功，是否会收到微信支付的通知

#### 易用性
- 红包描述，可以通过语音输入
- 可以指纹支付也可以密码支付

---

### 微信朋友圈测试

#### 功能测试

##### 朋友圈发送功能
- 发送纯文本：包括文本长度、类型、复制粘贴支持、空验证。
- 发送图片：包括选择来源、数量、格式、尺寸、大小、预览、增删改操作、空验证。
- 发送视频：包括选择来源、秒数、格式、大小、预览、增删改操作、空验证。
- 发送组合内容：文本+图片、文本+视频（注意不支持图片+视频）。
- 发送内容限制：检查是否有敏感内容限制。
- 所在位置：不显示位置、选择位置、点击取消。
- 谁可以看：公开、私密、部分可见、不给谁看，检查设置和取消操作。
- 提醒谁看：提醒单人/多人、人数上限、取消操作
- 同步QQ空间：同步与否的设置。
- 取消发送操作：包括从相机选择和编辑过程中的取消。

##### 朋友圈浏览功能
- 文本查看：隐藏、复制、收藏、翻译、链接跳转。
- 图片查看：收藏、编辑、大图浏览、发送、保存、滑动浏览。
- 视频查看：静音播放、搜藏、播放、发送、保存、编辑。
- 分享动态：检查QQ空间、公众号文章、非腾讯产品分享的显示。
- 赞和取消赞。
- 评论：长度、类型、复制粘贴、空验证、删除、回复操作。
- 删除朋友圈动态。
- 更换相册封面
- 刷新和加载更多动态。

#### 界面易用性测试
- 页面布局与产品原型图/UI效果图的一致性。
- 操作的简便性、页面布局的美观合理性、提示语的易懂性。

#### 网络测试
- 三大运营商不同网络制式测试
- 网络切换测试：WIFI/4G/3G/2G
- 无网测试：对于缓存在本地的数据，部分朋友圈信息是否支持浏览
- 弱网测试：
    - 延时：页面响应时间是否可接受、不同网络制式是否区分超时时长、出现请求超时，是否给予相应的提示
    - 丢包：有无超时重连机制、如果未响应，是否给予相应提示
    - 页面呈现的完整性验证

#### 兼容性测试
- Android手机端、苹果手机端、pad版（主流）功能界面显示是否正常
- 各平台朋友圈展示数据是否一致

#### 性能测试
- 服务器性能测试:可通过loadrunner/jmeter工具实现，主要关注TPS、响应时间、吞吐量、CPU、内存等
- app客户端性能测试: 可通过GT工具实现，运行时关注cpu、内存、流量、电量等占用率
- app压力稳定性测试: 通过monkey工具实现，频繁发送朋友圈，浏览朋友圈请求，是否容易发生崩溃

#### 安全性测试
- 检查是否有潜在的安全漏洞，如SQL注入、XSS攻击等

#### 中断测试
- 主要考虑：a)核心功能 b)当前功能存在实时数据交换，例发朋友圈、浏览朋友圈进行中断，是否容易出现崩溃
- 中断包括：前后台切换、锁屏解锁、断网重连、app切换、来电话/来短信中断、插拔耳机线/数据线

---

### 说一说用户界面登录过程都需要做哪些测试

#### 功能测试
- 输入正确的用户名和密码，点击提交按钮，验证是否能正确登录，登录成功后能否能否跳转到正确的页面
- 输入错误的用户名或者密码,验证登录会失败，并且提示相应的错误信息。
- 用户名和密码，如果太短或者太长，应该怎么处理
- 用户名和密码，中有特殊字符（比如空格），和其他非英文的情况
- 记住用户名的功能
- 登陆失败后，不能记录密码的功能
- 用户名和密码前后有空格的处理
- 密码是否非明文显示显示，使用星号圆点等符号代替。
- 牵扯到验证码的，还要考虑文字是否扭曲过度导致辨认难度大，考虑颜色（色盲使用者），刷新或换一个按钮是否好用
- 输入密码的时候，大写键盘开启的时候要有提示信息。
- 什么都不输入，点击提交按钮，检查提示信息。

#### 界面测试
- 布局是否合理
- 界面的设计风格是否与UI的设计风格统一。
- 界面中的文字简洁易懂，没有错别字。

#### 性能测试
- 打开登录页面，需要的时间是否在需求要求的时间内。
- 输入正确的用户名和密码后，检查登录成功跳转到新页面的时间是否在需求要求的时间内。
- 模拟大量用户同时登陆，检查一定压力下能否正常登陆跳转。

#### 安全性测试
- 登录成功后生成的Cookie，是否是httponly (否则容易被脚本盗取)。
- 用户名和密码是否通过加密的方式，发送给Web服务器。
- 用户名和密码的验证，应该是用服务器端验证， 而不能单单是在客户端用javascript 验证。
- 用户名和密码的输入框，应该屏蔽SQL注入攻击。
- 用户名和密码的的输入框，应该禁止输入脚本 （防止XSS攻击）。
- 防止暴力破解，检测是否有错误登陆的次数限制。
- 是否支持多用户在同一机器上登录。
- 同一用户能否在多台机器上登录。

#### 可用性测试
- 是否可以全用键盘操作，是否有快捷键。
- 输入用户名，密码后按回车，是否可以登陆。
- 输入框能否可以以Tab键切换。

#### 兼容性测试
- 不同浏览器下能否显示正常且功能正常（IE, Firefox, Chrome, Safari,等）。
- 同种浏览器不同版本下能否显示正常且功能正常。
- 不同的平台是否能正常工作，比如Windows, Mac。
- 移动设备上是否正常工作，比如Iphone, Andriod。
- 不同的分辨率下显示是否正常。

---

### 购物车测试用例设计？

#### 界面测试
- 界面布局、排版是否合理；文字是否显示清晰；不同卖家的商品是否区分明显。

#### 功能测试

##### 未登录时：
- 将商品加入购物车，页面跳转到登录页面，登录成功后购物车数量增加；
- 击购物车菜单，页面跳转到登录页面。

##### 登录后：
- 所有链接是否跳转正确；
- 商品是否可以成功加入购物车；
- 购物车商品总数是否有限制；
- 商品总数是否正确；
- 全选功能是否好用；
- 删除功能是否好用；
- 填写委托单功能是否好用；
- 委托单中填写的价格是否正确显示；
- 价格总计是否正确；
- 商品文字太长时是否显示完整；
- 店铺名字太长时是否显示完整；
- 创新券商品是否打标；
- 购物车中下架的商品是否有特殊标识；
- 新加入购物车商品排序（添加购物车中存在店铺的商品和购物车中不存在店铺的商品）；
- 是否支持TAB、ENTER等快捷键；
- 商品删除后商品总数是否减少；
- 购物车结算功能是否好用。

#### 兼容性测试
- 在不同浏览器测试

#### 易用性测试
- 删除功能是否有提示；是否有回到顶部的功能；商品过多时结算按钮是否可以浮动显示。

#### 性能测试
- 压力测试；并发测试。

---

### 迭代器和生成器有什么区别？

- **迭代器**是一个实现了迭代器协议的对象，拥有__iter__()和__next__()方法的对象。迭代器可以用于任何可迭代的对象，如列表、字典等。

- **生成器**是一种特殊的迭代器，它通过使用yield关键字在函数中创建。生成器在每次迭代时计算下一个值。

- 迭代器主要用于遍历已存在的数据结构，如列表、字典等。生成器则用于在需要时生成数据，适用于大数据集或需要动态生成数据的场景。

---

### 元组和列表的区别

- 元组和列表都是序列，可以存储任何数据类型，并通过索引访问。
- 列表是可变的，可以修改、添加或删除元素。元组是不可变的，一旦创建就不能更改。
- 列表适合用于存储需要动态改变的数据集合。 元组适合用于确保数据不被修改的情况，例如作为字典的键。

---

### Python都有那些数据类型

1. **数值类型:**
    - 整型 (int): 表示整数，如 -3, 0, 42。
    - 浮点型 (float): 表示带有小数点的数字，如 -3.14, 0.0, 2.78。

2. **布尔类型 (bool):** 表示逻辑值 True 或 False。

3. **字符串类型 (str):** 表示文本数据，由字符组成的序列，如 'hello', "world"。

4. **列表 (list):** 有序的集合，可以包含不同类型的元素，如 [1, 'a', 3.14]。

5. **元组 (tuple):** 有序的不可变序列，一旦创建就不能修改，如 (1, 'a', 3.14)。

6. **字典 (dict):** 无序的键值对集合，键必须是不可变类型，如 {'name': 'Alice', 'age': 25}。

7. **集合 (set):** 无序的唯一元素集，自动去重，如 {1, 2, 3}。

8. **None 类型 (NoneType):** 只有一个值 None，常用于表示空值或无值。

---


